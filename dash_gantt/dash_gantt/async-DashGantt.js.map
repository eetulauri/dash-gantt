{"version":3,"file":"async-DashGantt.js","mappings":"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","sources":["webpack:///./src/lib/fragments/DashGantt.react.js"],"sourcesContent":["import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * DashGantt is a Gantt chart component for scheduling.\n * It displays professionals vertically and time horizontally.\n * Users can add, modify, and remove timeslots for each professional.\n * The component outputs data that can be used in a prediction model.\n */\nexport default class DashGantt extends Component {\n    constructor(props) {\n        super(props);\n        \n        this.state = {\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            },\n            hoveredCell: null,\n            // Cache for slot width calculations to avoid repeated calculations\n            slotWidthCache: {}\n        };\n        \n        // Bind methods\n        this.handleSlotClick = this.handleSlotClick.bind(this);\n        this.handleAddSlot = this.handleAddSlot.bind(this);\n        this.handleCreateSlot = this.handleCreateSlot.bind(this);\n        this.handleRemoveSlot = this.handleRemoveSlot.bind(this);\n        this.handleSaveSlot = this.handleSaveSlot.bind(this);\n        this.handleCancelEdit = this.handleCancelEdit.bind(this);\n        this.handleCellHover = this.handleCellHover.bind(this);\n        this.handleCellLeave = this.handleCellLeave.bind(this);\n        this.renderSlotRectangle = this.renderSlotRectangle.bind(this);\n        this.generateTimeCells = this.generateTimeCells.bind(this);\n        this.formatTime = this.formatTime.bind(this);\n        this.timeToDecimal = this.timeToDecimal.bind(this);\n        this.calculateSlotWidth = this.calculateSlotWidth.bind(this);\n        this.getSlotWidth = this.getSlotWidth.bind(this);\n    }\n    \n    // Handle clicking on a timeslot\n    handleSlotClick(slot) {\n        this.setState({\n            selectedSlot: slot,\n            isAddingSlot: false\n        });\n    }\n    \n    // Handle cell hover\n    handleCellHover(professionalId, hour, minute) {\n        // Avoid unnecessary state updates if hovering over the same cell\n        const currentHover = this.state.hoveredCell;\n        if (currentHover && \n            currentHover.professionalId === professionalId && \n            currentHover.hour === hour && \n            currentHover.minute === minute) {\n            return; // No change needed\n        }\n        \n        // Update the hover state\n        this.setState({\n            hoveredCell: { professionalId, hour, minute }\n        });\n    }\n    \n    // Handle cell leave\n    handleCellLeave() {\n        // Only update state if we're currently hovering over a cell\n        if (this.state.hoveredCell !== null) {\n            this.setState({\n                hoveredCell: null\n            });\n        }\n    }\n    \n    // Handle creating a new timeslot with a single click\n    handleCreateSlot(professionalId, hour, minute) {\n        const { timeslots, date, setProps } = this.props;\n        \n        // Calculate start and end times\n        const startHour = Math.floor(hour);\n        const startMinutes = minute;\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\n        \n        // Always create a 20-minute slot as per business requirements\n        const slotDurationMinutes = 20; // Fixed 20-minute duration for created slots\n        \n        // Calculate end time, ensuring exact 20-minute duration\n        // We use integer math to avoid floating-point precision issues\n        const totalStartMinutes = (startHour * 60) + startMinutes;\n        const totalEndMinutes = totalStartMinutes + slotDurationMinutes;\n        const endHour = Math.floor(totalEndMinutes / 60);\n        const endMinutes = totalEndMinutes % 60;\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\n        \n        // Create new slot\n        const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\n        const slotToAdd = {\n            id: newId,\n            professionalId: professionalId,\n            start: startTime,\n            end: endTime,\n            date: date,\n            bookingProbability: 0.5 // Default probability, can be updated later by prediction model\n        };\n        \n        // Update timeslots\n        const updatedTimeslots = [...timeslots, slotToAdd];\n        setProps({ timeslots: updatedTimeslots });\n    }\n    \n    // Handle adding a new timeslot\n    handleAddSlot(professionalId, hour, minute) {\n        const { slotDuration } = this.props;\n        const startHour = Math.floor(hour);\n        const startMinutes = minute;\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\n        \n        const endTimeInMinutes = startHour * 60 + startMinutes + slotDuration;\n        const endHour = Math.floor(endTimeInMinutes / 60);\n        const endMinutes = endTimeInMinutes % 60;\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\n        \n        this.setState({\n            isAddingSlot: true,\n            selectedSlot: null,\n            newSlot: {\n                professionalId,\n                start: startTime,\n                end: endTime\n            }\n        });\n    }\n    \n    // Handle removing a timeslot\n    handleRemoveSlot(slotId) {\n        const { timeslots, setProps } = this.props;\n        const updatedTimeslots = timeslots.filter(slot => slot.id !== slotId);\n        \n        setProps({ timeslots: updatedTimeslots });\n        this.setState({ selectedSlot: null });\n    }\n    \n    // Handle saving a timeslot (new or edited)\n    handleSaveSlot() {\n        const { timeslots, date, setProps } = this.props;\n        const { selectedSlot, newSlot, isAddingSlot } = this.state;\n        \n        let updatedTimeslots;\n        \n        if (isAddingSlot) {\n            // Add new slot\n            const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\n            const slotToAdd = {\n                id: newId,\n                professionalId: newSlot.professionalId,\n                start: newSlot.start,\n                end: newSlot.end,\n                date: date\n            };\n            \n            updatedTimeslots = [...timeslots, slotToAdd];\n        } else {\n            // Update existing slot\n            updatedTimeslots = timeslots.map(slot => \n                slot.id === selectedSlot.id ? { ...slot, ...selectedSlot } : slot\n            );\n        }\n        \n        setProps({ timeslots: updatedTimeslots });\n        this.setState({\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            }\n        });\n    }\n    \n    // Handle canceling edit or add operation\n    handleCancelEdit() {\n        this.setState({\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            }\n        });\n    }\n    \n    // Convert time string to decimal hours\n    timeToDecimal(timeStr) {\n        const [hours, minutes] = timeStr.split(':').map(Number);\n        return hours + (minutes / 60);\n    }\n    \n    // Calculate the width of a slot that should span multiple cells\n    calculateSlotWidth(start, end, slotDuration) {\n        // Calculate duration in minutes\n        const startDecimal = this.timeToDecimal(start);\n        const endDecimal = this.timeToDecimal(end);\n        const durationInHours = endDecimal - startDecimal;\n        const durationInMinutes = durationInHours * 60;\n        \n        // Calculate how many grid cells this should span\n        // To avoid floating-point precision issues, round to the nearest integer\n        // For a 20-minute duration with 5-minute slots, this should consistently give 4 cells\n        const numCells = Math.round(durationInMinutes / slotDuration);\n        \n        // Log the calculation only in development mode to reduce console noise\n        if (process.env.NODE_ENV === 'development') {\n            console.log(`Slot ${start}-${end}: Duration=${durationInMinutes}min, Spans ${numCells} cells`);\n        }\n        \n        // Return the exact number of cells to span (minimum 1)\n        return Math.max(1, numCells);\n    }\n    \n    // Format decimal hours to time string\n    decimalToTime(decimal) {\n        const hours = Math.floor(decimal);\n        const minutes = Math.round((decimal - hours) * 60);\n        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n    }\n    \n    // Get color based on booking probability and booking status\n    getProbabilityColor(slot) {\n        // If the slot is booked, use a dark blue color\n        if (slot.isBooked) {\n            return '#1a237e'; // Dark blue for booked slots\n        }\n        \n        // For unbooked slots, use probability-based colors\n        const probability = slot.bookingProbability;\n        if (probability === undefined) return '#4CAF50'; // Default green\n        \n        // Clamp probability between 0 and 1 for safety\n        const p = Math.max(0, Math.min(1, probability));\n        \n        let r, g, b;\n        \n        // For the first half (0 to 0.5), transition from red to yellow\n        // For the second half (0.5 to 1), transition from yellow to green\n        if (p < 0.5) {\n            // Red to Yellow: Red stays at 255, Green increases\n            r = 255;\n            g = Math.round(255 * (p * 2)); // *2 to reach 255 at p=0.5\n            b = 0;\n        } else {\n            // Yellow to Green: Green stays at 255, Red decreases\n            r = Math.round(255 * (1 - (p - 0.5) * 2)); // -0.5 and *2 to start from 255 and reach 0 at p=1\n            g = 255;\n            b = 0;\n        }\n        \n        return `rgb(${r}, ${g}, ${b})`;\n    }\n    \n    // Render a single slot rectangle\n    renderSlotRectangle(slot) {\n        const { slotDuration } = this.props;\n        \n        // Get the number of cells this slot should span (using cached value if available)\n        const numCellsToSpan = this.getSlotWidth(slot, slotDuration);\n        \n        // We need to make the rectangle fill exactly the grid cells it should span\n        // Calculate width to exactly fill the grid cells\n        const slotStyle = {\n            position: 'absolute',\n            top: '4px',\n            left: '0',\n            height: 'calc(100% - 8px)',\n            // For a consistent calculation that accounts for grid lines:\n            // - Multiply by 100% to get the percentage width\n            // - Add (numCells-1) pixels to account for the internal borders\n            width: `calc(${numCellsToSpan * 100}% + ${numCellsToSpan - 1}px)`,\n            // Set box-sizing to border-box to include borders in element's dimensions\n            boxSizing: 'border-box',\n            backgroundColor: this.getProbabilityColor(slot),\n            color: 'white',\n            borderRadius: '3px', // Slightly less rounded for cleaner look\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center',\n            cursor: slot.isBooked ? 'not-allowed' : 'pointer',\n            boxShadow: '0 1px 2px rgba(0,0,0,0.1)', // Lighter shadow for simple_white theme\n            zIndex: 100,\n            transition: 'all 0.15s ease-in-out',\n            opacity: slot.isBooked ? 0.8 : 1\n        };\n        \n        return (\n            <div \n                key={`slot-${slot.id}`} \n                style={slotStyle}\n                onClick={(e) => {\n                    e.stopPropagation();\n                    if (!slot.isBooked) {\n                        this.handleSlotClick(slot);\n                    }\n                }}\n                title={`Time slot: ${slot.start} - ${slot.end}\nType: ${slot.appointmentType}\nResource: ${slot.resource}\n${slot.isBooked ? 'Status: Booked' : `Booking probability: ${Math.round(slot.bookingProbability * 100)}%`}`}\n            >\n            </div>\n        );\n    }\n    \n    // Format time for display (HH:MM)\n    formatTime(hour, minute) {\n        return `${Math.floor(hour).toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n    }\n    \n    // Generate time cells for each hour and minute interval\n    generateTimeCells(professional, styles) {\n        const { timeslots, startHour, endHour, slotDuration } = this.props;\n        const slotsPerHour = 60 / slotDuration;\n        const cells = [];\n        \n        // Only filter slots for this professional once\n        const professionalSlots = timeslots.filter(slot => slot.professionalId === professional.id);\n        \n        // Group slots by their start time for more efficient lookup\n        const slotsByStartTime = {};\n        professionalSlots.forEach(slot => {\n            const [hour, minute] = slot.start.split(':').map(Number);\n            const key = `${hour}:${minute}`;\n            slotsByStartTime[key] = slot;\n        });\n        \n        // Pre-create styles for hover state to reduce object creation during render\n        const hoverStyle = {\n            position: 'absolute',\n            bottom: '2px',\n            right: '2px',\n            fontSize: '10px',\n            color: '#666',\n            pointerEvents: 'none',\n            backgroundColor: 'rgba(255, 255, 255, 0.7)',\n            padding: '1px 3px',\n            borderRadius: '2px',\n            zIndex: 200\n        };\n        \n        // Iterate through each time slot for this professional\n        for (let hour = startHour; hour <= endHour; hour++) {\n            for (let minuteIndex = 0; minuteIndex < slotsPerHour; minuteIndex++) {\n                const minute = minuteIndex * slotDuration;\n                const timeKey = `${hour}:${minute}`;\n                const displayTimeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n                \n                // Check if this cell is the start of a time slot\n                const slot = slotsByStartTime[timeKey];\n                \n                const isHovered = this.state.hoveredCell && \n                                this.state.hoveredCell.professionalId === professional.id && \n                                this.state.hoveredCell.hour === hour &&\n                                this.state.hoveredCell.minute === minute;\n                \n                // Format time for display in the hover tooltip\n                const timeDisplay = this.formatTime(hour, minute);\n                \n                // Create a consistent cell style with proper borders\n                // Hour borders are thicker for better visual separation\n                const cellStyle = {\n                    ...styles.dashGanttTimeCell,\n                    backgroundColor: isHovered ? '#fafafa' : 'transparent',\n                    borderLeft: minute === 0 ? '1px solid #eaeaea' : 'none',  // Only show left border at hour boundaries\n                    position: 'relative'\n                };\n                \n                // Create the cell for this time slot\n                const cell = (\n                    <td \n                        key={`cell-${professional.id}-${displayTimeKey}`} \n                        style={cellStyle}\n                        onClick={() => this.handleCreateSlot(professional.id, hour, minute)}\n                        onMouseEnter={() => this.handleCellHover(professional.id, hour, minute)}\n                        onMouseLeave={this.handleCellLeave}\n                        title={`Time: ${timeDisplay}`}\n                    >\n                        {slot && this.renderSlotRectangle(slot)}\n                        \n                        {/* Show time on hover */}\n                        {isHovered && (\n                            <div style={{\n                                position: 'absolute', \n                                bottom: '2px', \n                                right: '2px', \n                                fontSize: '10px', \n                                color: '#666', \n                                pointerEvents: 'none',\n                                backgroundColor: 'rgba(255, 255, 255, 0.8)', \n                                padding: '1px 3px', \n                                borderRadius: '2px', \n                                zIndex: 200,\n                                border: '1px solid #eaeaea'\n                            }}>\n                                {timeDisplay}\n                            </div>\n                        )}\n                    </td>\n                );\n                \n                cells.push(cell);\n            }\n        }\n        \n        return cells;\n    }\n    \n    // Get cached slot width or calculate it if not in cache\n    getSlotWidth(slot, slotDuration) {\n        // Create a unique key for this slot and duration\n        const cacheKey = `${slot.id}_${slot.start}_${slot.end}_${slotDuration}`;\n        \n        // If we have a cached value, use it\n        if (this.state.slotWidthCache[cacheKey] !== undefined) {\n            return this.state.slotWidthCache[cacheKey];\n        }\n        \n        // Otherwise, calculate and cache the value\n        const width = this.calculateSlotWidth(slot.start, slot.end, slotDuration);\n        \n        // Update the cache (without triggering a re-render)\n        // We can safely update state directly here since we're not using setState\n        // and this won't trigger a re-render - it's just for caching\n        this.state.slotWidthCache[cacheKey] = width;\n        \n        return width;\n    }\n    \n    // Optimize rendering by preventing unnecessary re-renders\n    shouldComponentUpdate(nextProps, nextState) {\n        // We need to allow hover state changes to trigger re-renders for hover effects\n        // but we can still optimize by not recalculating slot widths\n        \n        // For any state or prop changes, we should re-render\n        // But we can optimize calculations inside the render cycle\n        return true;\n    }\n    \n    // Reset cache when props change\n    componentDidUpdate(prevProps) {\n        // If timeslots change, clear the width cache to ensure correct calculations\n        if (prevProps.timeslots !== this.props.timeslots || \n            prevProps.slotDuration !== this.props.slotDuration) {\n            this.setState({\n                slotWidthCache: {}\n            });\n        }\n    }\n    \n    render() {\n        const { id, professionals, date, timeslots, startHour, endHour, slotDuration } = this.props;\n        \n        // Calculate number of time slots per hour (e.g., 12 for 5-minute slots)\n        const slotsPerHour = 60 / slotDuration;\n        \n        // Calculate total number of slots in the timeline\n        const totalSlots = (endHour - startHour) * slotsPerHour;\n        \n        // Calculate a reasonable cell width in pixels - each hour should be at least 60px wide\n        const hourWidth = 60;\n        const cellWidth = hourWidth / slotsPerHour;\n        \n        const styles = {\n            dashGantt: {\n                fontFamily: 'Arial, sans-serif',\n                margin: '20px 0'\n            },\n            dashGanttHeader: {\n                marginBottom: '10px'\n            },\n            dashGanttContainer: {\n                border: '1px solid #e0e0e0', // Even lighter border for simple_white theme\n                borderRadius: '4px', // Less rounded corners for clean look\n                overflow: 'hidden',\n                overflowX: 'auto',\n                boxShadow: 'none' // No shadow for minimalist look\n            },\n            dashGanttTable: {\n                width: '100%',\n                borderCollapse: 'collapse',\n                tableLayout: 'fixed',\n                // Each hour is at least hourWidth pixels, plus professional column\n                minWidth: `${150 + (endHour - startHour) * hourWidth}px`\n            },\n            dashGanttHeaderRow: {\n                backgroundColor: this.props.backgroundColor || '#ffffff' // White background like simple_white theme\n            },\n            dashGanttHeaderCell: {\n                padding: '12px 8px', \n                textAlign: 'center',\n                fontWeight: '500', // Medium weight for cleaner look\n                borderRight: '1px solid #eaeaea', // Very light border\n                borderBottom: '1px solid #eaeaea',\n                fontSize: '14px',\n                color: '#444' // Darker text for better readability\n            },\n            dashGanttFirstHeaderCell: {\n                width: '150px',\n                borderRight: '1px solid #eaeaea',\n                borderBottom: '1px solid #eaeaea'\n            },\n            dashGanttRow: {\n                height: '60px'\n            },\n            dashGanttProfessionalCell: {\n                width: '150px',\n                padding: '8px',\n                borderRight: '1px solid #eaeaea',\n                borderBottom: '1px solid #eaeaea',\n                backgroundColor: this.props.backgroundColor || '#ffffff', // Use same background color as headers\n                verticalAlign: 'middle',\n                fontWeight: '500',\n                fontSize: '14px',\n                color: '#444'\n            },\n            dashGanttTimeCell: {\n                position: 'relative',\n                padding: '0',\n                borderRight: '1px solid #f5f5f5', // Very subtle grid lines\n                borderBottom: '1px solid #eaeaea',\n                cursor: 'pointer',\n                height: '60px',\n                // We're setting a minimum width based on a reasonable cell size\n                minWidth: '5px', \n                width: `${100 / totalSlots}%`,\n                boxSizing: 'border-box',\n                transition: 'background-color 0.2s ease'\n            },\n            dashGanttSlot: {\n                position: 'absolute',\n                top: '0',\n                height: '100%',\n                backgroundColor: '#4CAF50',\n                color: 'white',\n                borderRadius: '4px',\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                cursor: 'pointer',\n                boxShadow: '0 1px 3px rgba(0,0,0,0.1)', // Lighter shadow for cleaner look\n                zIndex: 10,\n                overflow: 'hidden'\n            },\n            dashGanttProbability: {\n                fontSize: '14px',\n                fontWeight: '500'\n            },\n            dashGanttEditor: {\n                marginTop: '20px',\n                padding: '15px',\n                border: '1px solid #eaeaea', // Lighter border for simple_white\n                borderRadius: '4px',\n                backgroundColor: '#ffffff' // Pure white background\n            },\n            dashGanttForm: {\n                display: 'flex',\n                flexDirection: 'column',\n                gap: '10px'\n            },\n            dashGanttFormGroup: {\n                display: 'flex',\n                alignItems: 'center'\n            },\n            dashGanttFormGroupLabel: {\n                width: '100px',\n                marginRight: '10px',\n                color: '#444',\n                fontSize: '14px'\n            },\n            dashGanttFormGroupInput: {\n                flex: 1,\n                padding: '8px',\n                border: '1px solid #eaeaea',\n                borderRadius: '4px',\n                fontSize: '14px'\n            },\n            dashGanttFormActions: {\n                display: 'flex',\n                gap: '10px',\n                marginTop: '10px'\n            },\n            dashGanttFormActionsButton: {\n                padding: '8px 15px',\n                border: 'none',\n                borderRadius: '4px',\n                cursor: 'pointer',\n                fontWeight: '500',\n                fontSize: '14px'\n            },\n            dashGanttFormActionsSave: {\n                backgroundColor: '#2196F3', // Using blue for primary action\n                color: 'white'\n            },\n            dashGanttFormActionsCancel: {\n                backgroundColor: '#f5f5f5',\n                color: '#333'\n            },\n            dashGanttFormActionsRemove: {\n                backgroundColor: '#f44336',\n                color: 'white'\n            }\n        };\n        \n        // Generate hour labels\n        const hourLabels = [];\n        for (let hour = startHour; hour <= endHour; hour++) {\n            const displayHour = hour % 24; // Handle 24-hour format\n            const isPM = displayHour >= 12;\n            const display12Hour = displayHour === 0 ? 12 : (displayHour > 12 ? displayHour - 12 : displayHour);\n            const timeLabel = `${display12Hour}${isPM ? 'PM' : 'AM'}`;\n            hourLabels.push(timeLabel);\n        }\n        \n        // Generate hour header cells\n        const generateHourHeaderCells = () => {\n            const cells = [];\n            \n            for (let hour = startHour; hour <= endHour; hour++) {\n                // Use 24-hour format (European style)\n                // Ensure we're not exceeding 24 hours (handle edge case for endHour=24)\n                const displayHour = hour === 24 ? 24 : hour % 24;\n                // Format as 2-digit hour (e.g., \"06\" instead of \"6\")\n                const timeLabel = `${displayHour.toString().padStart(2, '0')}:00`;\n                \n                cells.push(\n                    <th \n                        key={`header-${hour}`} \n                        colSpan={slotsPerHour}\n                        style={styles.dashGanttHeaderCell}\n                    >\n                        {timeLabel}\n                    </th>\n                );\n            }\n            \n            return cells;\n        };\n\n        return (\n            <div id={id} style={styles.dashGantt}>\n                <div style={styles.dashGanttHeader}>\n                    <h2>Schedule for {date}</h2>\n                </div>\n                <div style={styles.dashGanttContainer}>\n                    <table style={styles.dashGanttTable}>\n                        <thead>\n                            <tr style={styles.dashGanttHeaderRow}>\n                                <th style={styles.dashGanttFirstHeaderCell}></th>\n                                {generateHourHeaderCells()}\n                            </tr>\n                        </thead>\n                        <tbody>\n                            {professionals.map(professional => (\n                                <tr key={`row-${professional.id}`} style={styles.dashGanttRow}>\n                                    <td style={styles.dashGanttProfessionalCell}>\n                                        {professional.name}\n                                    </td>\n                                    {this.generateTimeCells(professional, styles)}\n                                </tr>\n                            ))}\n                        </tbody>\n                    </table>\n                </div>\n                \n                {/* Render slot editor */}\n                {this.state.selectedSlot || this.state.isAddingSlot ? (\n                    <div style={styles.dashGanttEditor}>\n                        <h3>{this.state.isAddingSlot ? 'Add New Slot' : 'Edit Slot'}</h3>\n                        <div style={styles.dashGanttForm}>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>Professional:</label>\n                                <select \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.professionalId : this.state.selectedSlot.professionalId} \n                                    onChange={e => {\n                                        const professionalId = parseInt(e.target.value);\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, professionalId } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, professionalId } });\n                                        }\n                                    }}\n                                    disabled={!this.state.isAddingSlot}\n                                >\n                                    {professionals.map(p => (\n                                        <option key={p.id} value={p.id}>{p.name}</option>\n                                    ))}\n                                </select>\n                            </div>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>Start Time:</label>\n                                <input \n                                    type=\"time\" \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.start : this.state.selectedSlot.start} \n                                    onChange={e => {\n                                        const start = e.target.value;\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, start } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, start } });\n                                        }\n                                    }}\n                                />\n                            </div>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>End Time:</label>\n                                <input \n                                    type=\"time\" \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.end : this.state.selectedSlot.end} \n                                    onChange={e => {\n                                        const end = e.target.value;\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, end } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, end } });\n                                        }\n                                    }}\n                                />\n                            </div>\n                            <div style={styles.dashGanttFormActions}>\n                                <button \n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsSave}}\n                                    onClick={this.handleSaveSlot}\n                                >\n                                    Save\n                                </button>\n                                <button \n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsCancel}}\n                                    onClick={this.handleCancelEdit}\n                                >\n                                    Cancel\n                                </button>\n                                {!this.state.isAddingSlot && (\n                                    <button \n                                        style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsRemove}}\n                                        onClick={() => this.handleRemoveSlot(this.state.selectedSlot.id)}\n                                    >\n                                        Remove\n                                    </button>\n                                )}\n                            </div>\n                        </div>\n                    </div>\n                ) : null}\n            </div>\n        );\n    }\n}\n\nDashGantt.defaultProps = {\n    timeslots: [],\n    date: new Date().toISOString().split('T')[0], // Today's date in YYYY-MM-DD format\n    startHour: 6, // 6:00 AM\n    endHour: 24, // Midnight\n    slotDuration: 20, // 20 minutes as per business requirements\n    backgroundColor: '#f5f5f5' // Default background color\n};\n\nDashGantt.propTypes = {\n    /**\n     * The ID used to identify this component in Dash callbacks.\n     */\n    id: PropTypes.string,\n\n    /**\n     * List of professionals to display in the Gantt chart.\n     * Each professional should have an id and name.\n     */\n    professionals: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.number.isRequired,\n            name: PropTypes.string.isRequired\n        })\n    ).isRequired,\n\n    /**\n     * List of timeslots to display in the Gantt chart.\n     * Each timeslot should have an id, professionalId, start time, end time, and date.\n     */\n    timeslots: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.number.isRequired,\n            professionalId: PropTypes.number.isRequired,\n            start: PropTypes.string.isRequired, // Format: \"HH:MM\"\n            end: PropTypes.string.isRequired, // Format: \"HH:MM\"\n            date: PropTypes.string.isRequired, // Format: \"YYYY-MM-DD\"\n            bookingProbability: PropTypes.number, // Optional: probability of booking (0-1)\n            isBooked: PropTypes.bool,\n            appointmentType: PropTypes.string,\n            resource: PropTypes.string\n        })\n    ),\n\n    /**\n     * The date to display in the Gantt chart (YYYY-MM-DD).\n     */\n    date: PropTypes.string,\n\n    /**\n     * The start hour of the day (e.g., 6 for 6:00 AM).\n     */\n    startHour: PropTypes.number,\n\n    /**\n     * The end hour of the day (e.g., 24 for midnight).\n     */\n    endHour: PropTypes.number,\n\n    /**\n     * The duration of each slot in minutes.\n     */\n    slotDuration: PropTypes.number,\n\n    /**\n     * The background color for the header row.\n     */\n    backgroundColor: PropTypes.string,\n\n    /**\n     * Dash-assigned callback that should be called to report property changes\n     * to Dash, to make them available for callbacks.\n     */\n    setProps: PropTypes.func\n};\n"],"names":["DashGantt","_Component","props","_this","_classCallCheck","_callSuper","state","selectedSlot","isAddingSlot","newSlot","professionalId","start","end","hoveredCell","slotWidthCache","handleSlotClick","bind","handleAddSlot","handleCreateSlot","handleRemoveSlot","handleSaveSlot","handleCancelEdit","handleCellHover","handleCellLeave","renderSlotRectangle","generateTimeCells","formatTime","timeToDecimal","calculateSlotWidth","getSlotWidth","_inherits","key","value","slot","this","setState","hour","minute","currentHover","_this$props","timeslots","date","setProps","startHour","Math","floor","startMinutes","startTime","concat","toString","padStart","totalEndMinutes","endHour","endMinutes","endTime","slotToAdd","id","length","max","apply","_toConsumableArray","map","bookingProbability","slotDuration","endTimeInMinutes","slotId","_this$props2","filter","updatedTimeslots","_this$props3","_this$state","_objectSpread","timeStr","_timeStr$split$map2","_slicedToArray","split","Number","startDecimal","durationInMinutes","numCells","round","decimal","hours","minutes","isBooked","probability","undefined","r","g","b","p","min","_this2","numCellsToSpan","slotStyle","position","top","left","height","width","boxSizing","backgroundColor","getProbabilityColor","color","borderRadius","display","justifyContent","alignItems","cursor","boxShadow","zIndex","transition","opacity","React","style","onClick","e","stopPropagation","title","appointmentType","resource","professional","styles","_this3","_this$props4","slotsPerHour","cells","professionalSlots","slotsByStartTime","forEach","_slot$start$split$map2","_loop","_loop2","minuteIndex","timeKey","displayTimeKey","isHovered","timeDisplay","cellStyle","dashGanttTimeCell","borderLeft","cell","onMouseEnter","onMouseLeave","bottom","right","fontSize","pointerEvents","padding","border","push","cacheKey","nextProps","nextState","prevProps","_this4","_this$props5","professionals","totalSlots","dashGantt","fontFamily","margin","dashGanttHeader","marginBottom","dashGanttContainer","overflow","overflowX","dashGanttTable","borderCollapse","tableLayout","minWidth","dashGanttHeaderRow","dashGanttHeaderCell","textAlign","fontWeight","borderRight","borderBottom","dashGanttFirstHeaderCell","dashGanttRow","dashGanttProfessionalCell","verticalAlign","dashGanttSlot","dashGanttProbability","dashGanttEditor","marginTop","dashGanttForm","flexDirection","gap","dashGanttFormGroup","dashGanttFormGroupLabel","marginRight","dashGanttFormGroupInput","flex","dashGanttFormActions","dashGanttFormActionsButton","dashGanttFormActionsSave","dashGanttFormActionsCancel","dashGanttFormActionsRemove","hourLabels","displayHour","isPM","timeLabel","colSpan","generateHourHeaderCells","name","onChange","parseInt","target","disabled","type","Component","defaultProps","Date","toISOString","propTypes","PropTypes","isRequired"],"sourceRoot":""}