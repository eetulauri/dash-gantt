{"version":3,"file":"async-DashGantt.js","mappings":"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","sources":["webpack:///./src/lib/fragments/DashGantt.react.js"],"sourcesContent":["import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * DashGantt is a Gantt chart component for scheduling.\n * It displays professionals vertically and time horizontally.\n * Users can add, modify, and remove timeslots for each professional.\n * The component outputs data that can be used in a prediction model.\n */\nexport default class DashGantt extends Component {\n    constructor(props) {\n        super(props);\n        \n        // Add table ref\n        this.tableRef = React.createRef();\n        \n        // Add a flag to track if we just finished dragging\n        this.justFinishedDragging = false;\n        \n        // Add flag for slot creation dragging\n        this.isCreatingSlot = false;\n        \n        // Initialize state with props\n        const { rawData, date } = props;\n        const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || new Date().toISOString().split('T')[0]);\n        \n        this.state = {\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            },\n            hoveredCell: null,\n            // Cache for slot width calculations to avoid repeated calculations\n            slotWidthCache: {},\n            // Internal state for transformed data\n            professionals: professionals || [],\n            timeslots: timeslots || [],\n            rawData: rawData || [],\n            date: date || new Date().toISOString().split('T')[0],\n            isDragging: false,\n            dragSide: null, // 'start' or 'end'\n            draggedSlot: null,\n            originalSlot: null,\n            dragPreview: null, // Will show preview of where slot will end up\n            dragType: null, // 'move', 'start', 'end', or 'create'\n            creationStart: null, // Starting point for new slot creation\n            creationEnd: null, // Ending point for new slot creation\n            creationProfessionalId: null, // Professional for whom the slot is being created\n        };\n        \n        // Bind methods\n        this.handleSlotClick = this.handleSlotClick.bind(this);\n        this.handleAddSlot = this.handleAddSlot.bind(this);\n        this.handleCreateSlot = this.handleCreateSlot.bind(this);\n        this.handleRemoveSlot = this.handleRemoveSlot.bind(this);\n        this.handleSaveSlot = this.handleSaveSlot.bind(this);\n        this.handleCancelEdit = this.handleCancelEdit.bind(this);\n        this.handleCellHover = this.handleCellHover.bind(this);\n        this.handleCellLeave = this.handleCellLeave.bind(this);\n        this.renderSlotRectangle = this.renderSlotRectangle.bind(this);\n        this.generateTimeCells = this.generateTimeCells.bind(this);\n        this.formatTime = this.formatTime.bind(this);\n        this.timeToDecimal = this.timeToDecimal.bind(this);\n        this.calculateSlotWidth = this.calculateSlotWidth.bind(this);\n        this.getSlotWidth = this.getSlotWidth.bind(this);\n        this.updateRawData = this.updateRawData.bind(this);\n        this.handleDragStart = this.handleDragStart.bind(this);\n        this.handleDrag = this.handleDrag.bind(this);\n        this.handleDragEnd = this.handleDragEnd.bind(this);\n        this.handleCreationStart = this.handleCreationStart.bind(this);\n        this.handleCreationDrag = this.handleCreationDrag.bind(this);\n        this.handleCreationEnd = this.handleCreationEnd.bind(this);\n    }\n    \n    // Transform raw data into component format\n    static transformData(rawData, date) {\n        if (!rawData || !date) return { professionals: [], timeslots: [] };\n\n        // Filter data for the specific date\n        const filteredData = rawData.filter(row => {\n            const rowDate = row.datetime.split(' ')[0];\n            return rowDate === date;\n        });\n\n        // Create professionals list from unique doctors\n        const professionals = Array.from(new Set(filteredData.map(row => row.laakari)))\n            .map((doctor, idx) => ({ id: idx + 1, name: doctor }));\n\n        // Create doctor to id mapping\n        const doctorToId = Object.fromEntries(\n            professionals.map((p, idx) => [p.name, idx + 1])\n        );\n\n        // Transform timeslots\n        const timeslots = filteredData.map((row, idx) => {\n            const [date, time] = row.datetime.split(' ');\n            const startTime = time;\n            \n            // Calculate end time based on duration\n            const [hours, minutes] = time.split(':').map(Number);\n            const startDate = new Date();\n            startDate.setHours(hours, minutes, 0);\n            // Use kesto_min directly from the data\n            const durationMinutes = row.kesto_min || 0;\n            const endDate = new Date(startDate.getTime() + durationMinutes * 60000);\n            const endTime = `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;\n\n            return {\n                id: idx + 1,\n                professionalId: doctorToId[row.laakari],\n                start: startTime,\n                end: endTime,\n                date: date,\n                durationMinutes: durationMinutes, // Store the original duration\n                bookingProbability: row.bookingProbability || 0.5,\n                isBooked: row.tyhja === 0,\n                rawData: row // Keep reference to original data with all fields\n            };\n        });\n\n        return { professionals, timeslots };\n    }\n    \n    // Update getDerivedStateFromProps to handle undefined values\n    static getDerivedStateFromProps(nextProps, prevState) {\n        if (!nextProps) return null;\n        \n        const { rawData, date } = nextProps;\n        if (rawData !== prevState.rawData || date !== prevState.date) {\n            const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || prevState.date);\n            return { \n                professionals: professionals || [], \n                timeslots: timeslots || [], \n                rawData: rawData || [], \n                date: date || prevState.date \n            };\n        }\n        return null;\n    }\n\n    // Update componentDidMount to handle undefined values\n    componentDidMount() {\n        const { rawData, date } = this.props;\n        const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || this.state.date);\n        this.setState({ \n            professionals: professionals || [], \n            timeslots: timeslots || [],\n            rawData: rawData || [],\n            date: date || this.state.date\n        });\n    }\n    \n    // Handle clicking on a timeslot\n    handleSlotClick(slot) {\n        this.setState({\n            selectedSlot: slot,\n            isAddingSlot: false\n        });\n    }\n    \n    // Handle cell hover\n    handleCellHover(professionalId, hour, minute) {\n        // Avoid unnecessary state updates if hovering over the same cell\n        const currentHover = this.state.hoveredCell;\n        if (currentHover && \n            currentHover.professionalId === professionalId && \n            currentHover.hour === hour && \n            currentHover.minute === minute) {\n            return; // No change needed\n        }\n        \n        // Update the hover state\n        this.setState({\n            hoveredCell: { professionalId, hour, minute }\n        });\n    }\n    \n    // Handle cell leave\n    handleCellLeave() {\n        // Only update state if we're currently hovering over a cell\n        if (this.state.hoveredCell !== null) {\n            this.setState({\n                hoveredCell: null\n            });\n        }\n    }\n    \n    // Handle creating a new timeslot with a single click\n    handleCreateSlot(professionalId, hour, minute) {\n        const { timeslots, date } = this.state;\n        \n        // Calculate start and end times\n        const startHour = Math.floor(hour);\n        const startMinutes = minute;\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\n        \n        // Always create a 20-minute slot as per business requirements\n        const slotDurationMinutes = 20;\n        \n        // Calculate end time\n        const totalStartMinutes = (startHour * 60) + startMinutes;\n        const totalEndMinutes = totalStartMinutes + slotDurationMinutes;\n        const endHour = Math.floor(totalEndMinutes / 60);\n        const endMinutes = totalEndMinutes % 60;\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\n        \n        // Create new slot\n        const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\n        const slotToAdd = {\n            id: newId,\n            professionalId: professionalId,\n            start: startTime,\n            end: endTime,\n            date: date,\n            bookingProbability: 0.5,\n            isBooked: false,\n            appointmentType: 'In-person appointment',\n            resource: 'Default',\n            rawData: null // New slot has no original data\n        };\n        \n        // Update timeslots and raw data\n        const updatedTimeslots = [...timeslots, slotToAdd];\n        this.setState({ timeslots: updatedTimeslots });\n        this.updateRawData(updatedTimeslots);\n    }\n    \n    // Handle adding a new timeslot\n    handleAddSlot(professionalId, hour, minute) {\n        const { slotDuration } = this.props;\n        const startHour = Math.floor(hour);\n        const startMinutes = minute;\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\n        \n        const endTimeInMinutes = startHour * 60 + startMinutes + slotDuration;\n        const endHour = Math.floor(endTimeInMinutes / 60);\n        const endMinutes = endTimeInMinutes % 60;\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\n        \n        this.setState({\n            isAddingSlot: true,\n            selectedSlot: null,\n            newSlot: {\n                professionalId,\n                start: startTime,\n                end: endTime\n            }\n        });\n    }\n    \n    // Handle removing a timeslot\n    handleRemoveSlot(slotId) {\n        // Make sure we're not in a drag operation\n        if (this.state.isDragging) {\n            this.resetDragState();\n        }\n        \n        const { timeslots } = this.state;\n        const updatedTimeslots = timeslots.filter(slot => slot.id !== slotId);\n        \n        this.setState({ \n            timeslots: updatedTimeslots,\n            selectedSlot: null\n        });\n        \n        this.updateRawData(updatedTimeslots);\n    }\n    \n    // Handle saving a timeslot (new or edited)\n    handleSaveSlot() {\n        const { timeslots } = this.state;\n        const { selectedSlot, newSlot, isAddingSlot } = this.state;\n        \n        let updatedTimeslots;\n        \n        if (isAddingSlot) {\n            // Add new slot\n            const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\n            const slotToAdd = {\n                id: newId,\n                professionalId: newSlot.professionalId,\n                start: newSlot.start,\n                end: newSlot.end,\n                date: this.props.date,\n                bookingProbability: 0.5,\n                isBooked: false,\n                appointmentType: 'In-person appointment',\n                resource: 'Default',\n                rawData: null\n            };\n            \n            updatedTimeslots = [...timeslots, slotToAdd];\n        } else {\n            // Update existing slot\n            updatedTimeslots = timeslots.map(slot => \n                slot.id === selectedSlot.id ? { ...slot, ...selectedSlot } : slot\n            );\n        }\n        \n        this.setState({\n            timeslots: updatedTimeslots,\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            }\n        });\n        \n        this.updateRawData(updatedTimeslots);\n    }\n    \n    // Handle canceling edit or add operation\n    handleCancelEdit() {\n        this.setState({\n            selectedSlot: null,\n            isAddingSlot: false,\n            newSlot: {\n                professionalId: null,\n                start: null,\n                end: null\n            }\n        });\n    }\n    \n    // Convert time string to decimal hours\n    timeToDecimal(timeStr) {\n        const [hours, minutes] = timeStr.split(':').map(Number);\n        return hours + (minutes / 60);\n    }\n    \n    // Calculate the width of a slot that should span multiple cells\n    calculateSlotWidth(start, end, slotDuration) {\n        // Calculate duration in minutes\n        const startDecimal = this.timeToDecimal(start);\n        const endDecimal = this.timeToDecimal(end);\n        const durationInHours = endDecimal - startDecimal;\n        const durationInMinutes = durationInHours * 60;\n        \n        // Calculate how many grid cells this should span\n        // To avoid floating-point precision issues, round to the nearest integer\n        // For a 20-minute duration with 5-minute slots, this should consistently give 4 cells\n        const numCells = Math.round(durationInMinutes / slotDuration);\n        \n        // Log the calculation only in development mode to reduce console noise\n        if (process.env.NODE_ENV === 'development') {\n            console.log(`Slot ${start}-${end}: Duration=${durationInMinutes}min, Spans ${numCells} cells`);\n        }\n        \n        // Return the exact number of cells to span (minimum 1)\n        return Math.max(1, numCells);\n    }\n    \n    // Format decimal hours to time string\n    decimalToTime(decimal) {\n        // Ensure we're dealing with a positive decimal\n        const positiveDecimal = Math.max(0, decimal);\n        \n        // Handle hours >= 24 by wrapping around\n        const wrappedDecimal = positiveDecimal % 24;\n        \n        const hours = Math.floor(wrappedDecimal);\n        const minutes = Math.round((wrappedDecimal - hours) * 60);\n        \n        // Handle case where minutes rounds to 60\n        const adjustedMinutes = minutes >= 60 ? 0 : minutes;\n        const adjustedHours = (minutes >= 60 ? hours + 1 : hours) % 24;\n        \n        return `${adjustedHours.toString().padStart(2, '0')}:${adjustedMinutes.toString().padStart(2, '0')}`;\n    }\n    \n    // Get color based on booking probability and booking status\n    getProbabilityColor(slot) {\n        // If the slot is booked, use a gray color\n        if (slot.isBooked) {\n            return '#808080'; // Gray color for booked slots\n        }\n        \n        // For unbooked slots, use probability-based colors from the provided palette\n        const probability = slot.bookingProbability;\n        if (probability === undefined) return 'rgb(0, 147, 146)'; // Default to first color in palette\n        \n        // Clamp probability between 0 and 1 for safety\n        const p = Math.max(0, Math.min(1, probability));\n        \n        // Define the color palette (from green to red)\n        const colorPalette = [\n            \"rgb(0, 147, 146)\",    // First green\n            \"rgb(57, 177, 133)\",\n            \"rgb(156, 203, 134)\",\n            \"rgb(233, 226, 156)\",  // Yellow-ish\n            \"rgb(238, 180, 121)\",\n            \"rgb(232, 132, 113)\",\n            \"rgb(207, 89, 126)\"    // Last red\n        ];\n        \n        // Calculate which color to use based on probability\n        // p=0 means highest index (most red), p=1 means lowest index (most green)\n        const index = Math.floor((1 - p) * (colorPalette.length - 1));\n        \n        return colorPalette[index];\n    }\n    \n    // Render a single slot rectangle\n    renderSlotRectangle(slot) {\n        if (!slot) return null;\n        \n        const { slotDuration } = this.props || {};\n        if (!slotDuration) return null;\n        \n        try {\n            // Get the number of cells this slot should span\n            const numCellsToSpan = this.getSlotWidth(slot, slotDuration);\n            \n            const slotStyle = {\n                position: 'absolute',\n                top: '2px',\n                left: '0',\n                height: 'calc(100% - 4px)',\n                width: `calc(${numCellsToSpan * 100}% + ${numCellsToSpan - 1}px)`,\n                boxSizing: 'border-box',\n                backgroundColor: this.getProbabilityColor(slot),\n                color: 'white',\n                borderRadius: '0',\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                cursor: slot.isBooked ? 'not-allowed' : (this.state.isDragging ? 'grabbing' : 'grab'),\n                boxShadow: '0 1px 2px rgba(0,0,0,0.1)',\n                zIndex: 100,\n                transition: 'all 0.15s ease-in-out',\n                opacity: 1\n            };\n            \n            // Make handles thinner - 1px instead of 4px\n            const handleStyle = {\n                position: 'absolute',\n                top: 0,\n                bottom: 0,\n                width: '1px', // 1px thin handles (visual appearance)\n                cursor: 'ew-resize',\n                backgroundColor: 'rgba(255, 255, 255, 0.5)', // Slightly more visible\n                transition: 'background-color 0.2s ease'\n            };\n\n            const leftHandleStyle = {\n                ...handleStyle,\n                left: 0, // Position at the edge\n                borderRadius: '0'\n            };\n\n            const rightHandleStyle = {\n                ...handleStyle,\n                right: 0, // Position at the edge\n                borderRadius: '0'\n            };\n            \n            // Add wider invisible handles for easier grabbing (clickable area)\n            const invisibleHandleStyle = {\n                position: 'absolute',\n                top: 0,\n                bottom: 0,\n                width: '3px', // 3px wide clickable area\n                cursor: 'ew-resize',\n                backgroundColor: 'transparent', // Invisible\n                zIndex: 101 // Higher z-index to ensure it's above the visible handle\n            };\n            \n            const leftInvisibleHandleStyle = {\n                ...invisibleHandleStyle,\n                left: '-1px' // Extend 1px to the left, keeping 2px inside\n            };\n            \n            const rightInvisibleHandleStyle = {\n                ...invisibleHandleStyle,\n                right: '-1px' // Extend 1px to the right, keeping 2px inside\n            };\n\n            return (\n                <div \n                    key={`slot-${slot.id}`} \n                    style={slotStyle}\n                    onClick={(e) => {\n                        e.stopPropagation();\n                        if (!slot.isBooked) {\n                            this.handleSlotClick(slot);\n                        }\n                    }}\n                    onMouseDown={(e) => {\n                        if (!slot.isBooked && e.target === e.currentTarget && e.button === 0) {\n                            this.handleDragStart(e, slot, 'move');\n                        }\n                    }}\n                    onContextMenu={(e) => {\n                        // This handles right-click\n                        e.preventDefault();\n                        e.stopPropagation();\n                        \n                        // Remove the slot if it's not booked\n                        // Note: We're removing the check for this.justFinishedDragging \n                        // since it's preventing legitimate right-clicks\n                        if (!slot.isBooked) {\n                            this.handleRemoveSlot(slot.id);\n                        }\n                    }}\n                    title={`Time slot: ${slot.start} - ${slot.end}\n${slot.isBooked ? 'Status: Booked' : `Booking probability: ${Math.round((slot.bookingProbability || 0.5) * 100)}%`}\nRight-click to remove\nDrag edges to resize\nDrag middle to move`}\n                >\n                    {!slot.isBooked && (\n                        <>\n                            {/* Visual handles (thin) */}\n                            <div\n                                style={leftHandleStyle}\n                                onMouseEnter={(e) => {\n                                    e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';\n                                }}\n                                onMouseLeave={(e) => {\n                                    e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n                                }}\n                            />\n                            <div\n                                style={rightHandleStyle}\n                                onMouseEnter={(e) => {\n                                    e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';\n                                }}\n                                onMouseLeave={(e) => {\n                                    e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n                                }}\n                            />\n                            \n                            {/* Invisible wider handles for easier grabbing */}\n                            <div\n                                style={leftInvisibleHandleStyle}\n                                onMouseDown={(e) => {\n                                    if (e.button === 0) { // Only handle left mouse button\n                                        this.handleDragStart(e, slot, 'start');\n                                    }\n                                }}\n                                onMouseEnter={(e) => {\n                                    const visibleHandle = e.currentTarget.previousSibling;\n                                    if (visibleHandle) {\n                                        visibleHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';\n                                    }\n                                }}\n                                onMouseLeave={(e) => {\n                                    const visibleHandle = e.currentTarget.previousSibling;\n                                    if (visibleHandle) {\n                                        visibleHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n                                    }\n                                }}\n                            />\n                            <div\n                                style={rightInvisibleHandleStyle}\n                                onMouseDown={(e) => {\n                                    if (e.button === 0) { // Only handle left mouse button\n                                        this.handleDragStart(e, slot, 'end');\n                                    }\n                                }}\n                                onMouseEnter={(e) => {\n                                    const visibleHandle = e.currentTarget.previousSibling.previousSibling;\n                                    if (visibleHandle) {\n                                        visibleHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';\n                                    }\n                                }}\n                                onMouseLeave={(e) => {\n                                    const visibleHandle = e.currentTarget.previousSibling.previousSibling;\n                                    if (visibleHandle) {\n                                        visibleHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';\n                                    }\n                                }}\n                            />\n                        </>\n                    )}\n                </div>\n            );\n        } catch (error) {\n            console.error(\"Error rendering slot rectangle:\", error);\n            return null;\n        }\n    }\n    \n    // Format time for display (HH:MM)\n    formatTime(hour, minute) {\n        return `${Math.floor(hour).toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n    }\n    \n    // Generate time cells for each hour and minute interval\n    generateTimeCells(professional, styles) {\n        const { startHour, endHour, slotDuration } = this.props;\n        const { timeslots, dragPreview, isDragging, dragType, creationStart, creationEnd, creationProfessionalId } = this.state;\n        const slotsPerHour = 60 / slotDuration;\n        const cells = [];\n        \n        // Filter slots for this professional\n        const professionalSlots = timeslots.filter(slot => slot.professionalId === professional.id);\n        \n        // Group slots by their start time\n        const slotsByStartTime = {};\n        professionalSlots.forEach(slot => {\n            const [hour, minute] = slot.start.split(':').map(Number);\n            const key = `${hour}:${minute}`;\n            slotsByStartTime[key] = slot;\n        });\n        \n        // Check if we are dragging a slot for this professional\n        const isPreviewingForThisProfessional = \n            dragPreview && dragPreview.professionalId === professional.id;\n        \n        // Determine which slots should be hidden during drag preview (only the one being dragged)\n        const slotBeingDragged = isDragging && isPreviewingForThisProfessional ? dragPreview.id : null;\n        \n        // Check if we're creating a slot for this professional\n        const isCreatingForThisProfessional = \n            isDragging && dragType === 'create' && creationProfessionalId === professional.id;\n        \n        // Calculate creation preview range if applicable\n        let creationStartDecimal = null;\n        let creationEndDecimal = null;\n        \n        if (isCreatingForThisProfessional && creationStart && creationEnd) {\n            creationStartDecimal = this.timeToDecimal(creationStart);\n            creationEndDecimal = this.timeToDecimal(creationEnd);\n            \n            // Ensure start is before end\n            if (creationEndDecimal < creationStartDecimal) {\n                [creationStartDecimal, creationEndDecimal] = [creationEndDecimal, creationStartDecimal];\n            }\n        }\n        \n        // For each time cell in the grid\n        for (let hour = startHour; hour <= endHour; hour++) {\n            for (let minuteIndex = 0; minuteIndex < slotsPerHour; minuteIndex++) {\n                const minute = minuteIndex * slotDuration;\n                const timeKey = `${hour}:${minute}`;\n                const displayTimeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n                \n                // Check if this cell is the start of a time slot\n                const slot = slotsByStartTime[timeKey];\n                \n                // Only show hover effect if not currently dragging\n                const isHovered = !isDragging && this.state.hoveredCell && \n                               this.state.hoveredCell.professionalId === professional.id && \n                               this.state.hoveredCell.hour === hour &&\n                               this.state.hoveredCell.minute === minute;\n                \n                // Format time for display in the hover tooltip\n                const timeDisplay = this.formatTime(hour, minute);\n                \n                // Determine if this is the first minute of the hour to add the hour marker\n                const isHourStart = minute === 0;\n                \n                // Create cell style with less pronounced hour marker\n                const cellStyle = {\n                    ...styles.dashGanttTimeCell,\n                    backgroundColor: isHovered ? 'rgba(33, 150, 243, 0.4)' : 'transparent',\n                    position: 'relative'\n                };\n                \n                // Check if this cell should show the preview\n                const cellTimeDecimal = hour + (minute / 60);\n                \n                // Check if this cell is in the normal drag preview range\n                const isInPreviewRange = isPreviewingForThisProfessional && \n                                      this.timeToDecimal(dragPreview.start) <= cellTimeDecimal && \n                                      this.timeToDecimal(dragPreview.end) > cellTimeDecimal;\n                \n                // Check if this cell is in the creation preview range\n                const isInCreationRange = isCreatingForThisProfessional && \n                                      creationStartDecimal <= cellTimeDecimal && \n                                      creationEndDecimal > cellTimeDecimal;\n                \n                // Prepare cell content\n                let cellContent;\n                \n                if (isDragging) {\n                    if (isInPreviewRange) {\n                        // Normal drag preview\n                        const borderStyle = 'solid';\n                        \n                        cellContent = (\n                            <>\n                                {/* Only show non-dragged slots */}\n                                {slot && slot.id !== slotBeingDragged && this.renderSlotRectangle(slot)}\n                                \n                                {/* Preview overlay */}\n                                <div style={{\n                                    position: 'absolute',\n                                    top: '2px',\n                                    left: '0',\n                                    right: '0',\n                                    bottom: '2px',\n                                    backgroundColor: 'rgba(33, 150, 243, 0.4)',\n                                    border: `1px ${borderStyle} #1976D2`,\n                                    pointerEvents: 'none',\n                                    zIndex: 95\n                                }} />\n                            </>\n                        );\n                    } else if (isInCreationRange) {\n                        // Creation preview\n                        cellContent = (\n                            <>\n                                {/* Continue showing existing slots during creation */}\n                                {slot && this.renderSlotRectangle(slot)}\n                                \n                                {/* Creation preview overlay */}\n                                <div style={{\n                                    position: 'absolute',\n                                    top: '2px',\n                                    left: '0',\n                                    right: '0',\n                                    bottom: '2px',\n                                    backgroundColor: 'rgba(76, 175, 80, 0.4)', // Green for creation\n                                    border: '1px dashed #388E3C',\n                                    pointerEvents: 'none',\n                                    zIndex: 90\n                                }} />\n                            </>\n                        );\n                    } else {\n                        // Cell not in any preview range\n                        cellContent = (\n                            <>\n                                {/* Hide original slot only if it's being dragged */}\n                                {(!isDragging || slot?.id !== slotBeingDragged) && slot && this.renderSlotRectangle(slot)}\n                            </>\n                        );\n                    }\n                } else {\n                    // Normal case - just show the slot if there is one\n                    cellContent = (\n                        <>\n                            {slot && this.renderSlotRectangle(slot)}\n                            \n                            {/* Only show hover tooltip if not dragging */}\n                            {isHovered && !isDragging && (\n                                <div style={{\n                                    position: 'absolute',\n                                    bottom: '2px',\n                                    right: '2px',\n                                    fontSize: '10px',\n                                    color: '#666',\n                                    pointerEvents: 'none',\n                                    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n                                    padding: '1px 3px',\n                                    borderRadius: '2px',\n                                    zIndex: 200,\n                                    border: '1px solid #eaeaea'\n                                }}>\n                                    {timeDisplay}\n                                </div>\n                            )}\n                        </>\n                    );\n                }\n                \n                // Create and add the cell\n                cells.push(\n                    <td \n                        key={`cell-${professional.id}-${displayTimeKey}`}\n                        style={cellStyle}\n                        onClick={(e) => {\n                            // Only create a slot on direct click if not dragging\n                            if (!this.isCreatingSlot && !this.justFinishedDragging) {\n                                this.handleCreateSlot(professional.id, hour, minute);\n                            }\n                        }}\n                        onMouseEnter={() => {\n                            // Only activate hover if not dragging\n                            if (!isDragging) {\n                                this.handleCellHover(professional.id, hour, minute);\n                            }\n                        }}\n                        onMouseLeave={() => {\n                            // Only handle leave if not dragging\n                            if (!isDragging) {\n                                this.handleCellLeave();\n                            }\n                        }}\n                        onMouseDown={(e) => {\n                            // Start creation drag when left-clicking on an empty cell\n                            if (e.button === 0 && !slot) {\n                                e.preventDefault();\n                                this.handleCreationStart(e, professional.id, hour, minute);\n                            }\n                        }}\n                        title={`Time: ${timeDisplay}\\nClick to add a 20-minute slot\\nClick and drag to create a custom-length slot`}\n                    >\n                        {cellContent}\n                    </td>\n                );\n            }\n        }\n        \n        return cells;\n    }\n    \n    // Get cached slot width or calculate it if not in cache\n    getSlotWidth(slot, slotDuration) {\n        if (!slot || !slot.start || !slot.end || !slotDuration) {\n            return 1; // Default to 1 if any required values are missing\n        }\n        \n        // Create a unique key for this slot and duration\n        const cacheKey = `${slot.id}_${slot.start}_${slot.end}_${slotDuration}`;\n        \n        // If we have a cached value, use it\n        if (this.state.slotWidthCache[cacheKey] !== undefined) {\n            return this.state.slotWidthCache[cacheKey];\n        }\n        \n        // Otherwise, calculate and cache the value\n        const width = this.calculateSlotWidth(slot.start, slot.end, slotDuration);\n        \n        // Update the cache (without triggering a re-render)\n        // We can safely update state directly here since we're not using setState\n        // and this won't trigger a re-render - it's just for caching\n        this.state.slotWidthCache[cacheKey] = width;\n        \n        return width;\n    }\n    \n    // Optimize rendering by preventing unnecessary re-renders\n    shouldComponentUpdate(nextProps, nextState) {\n        // We need to allow hover state changes to trigger re-renders for hover effects\n        // but we can still optimize by not recalculating slot widths\n        \n        // For any state or prop changes, we should re-render\n        // But we can optimize calculations inside the render cycle\n        return true;\n    }\n    \n    // Reset cache when props change\n    componentDidUpdate(prevProps) {\n        // If timeslots change, clear the width cache to ensure correct calculations\n        if (prevProps.timeslots !== this.props.timeslots || \n            prevProps.slotDuration !== this.props.slotDuration) {\n            this.setState({\n                slotWidthCache: {}\n            });\n        }\n    }\n    \n    // Update raw data when timeslots change\n    updateRawData(timeslots) {\n        const { rawData, onDataChange, setProps } = this.props;\n        \n        // Create a fresh array for the updated raw data\n        let updatedRawData = [];\n        \n        // First, filter existing data if needed\n        if (rawData && rawData.length > 0) {\n            // Keep track of which timeslots are still valid\n            const validTimeslots = new Set();\n            \n            // Generate lookup keys for all currently valid timeslots\n            timeslots.forEach(slot => {\n                const doctorName = this.state.professionals.find(p => p.id === slot.professionalId)?.name;\n                if (doctorName) {\n                    const key = `${slot.date} ${slot.start}_${doctorName}`;\n                    validTimeslots.add(key);\n                }\n            });\n            \n            // Only keep raw data items that correspond to slots we still have\n            updatedRawData = rawData.filter(item => {\n                // Skip items that don't have the required fields\n                if (!item.datetime || !item.laakari) return false;\n                \n                // Create a key to match against our valid timeslots\n                const key = `${item.datetime}_${item.laakari}`;\n                return validTimeslots.has(key);\n            });\n        }\n        \n        // Now process all current timeslots to update or add them\n        timeslots.forEach(timeslot => {\n            // Skip invalid timeslots\n            if (!this.isValidTime(timeslot.start) || !this.isValidTime(timeslot.end)) {\n                console.warn('Skipping invalid timeslot:', timeslot);\n                return;\n            }\n            \n            const originalData = timeslot.rawData;\n            const doctorName = this.state.professionals.find(p => p.id === timeslot.professionalId)?.name;\n            if (!doctorName) return;\n            \n            // For existing slots\n            if (originalData) {\n                // Calculate duration from start and end time\n                const [startHours, startMinutes] = timeslot.start.split(':').map(Number);\n                const [endHours, endMinutes] = timeslot.end.split(':').map(Number);\n                \n                // Handle crossing midnight if needed\n                let durationMinutes;\n                if (endHours < startHours || (endHours === startHours && endMinutes < startMinutes)) {\n                    // End time is on the next day\n                    durationMinutes = ((endHours + 24) * 60 + endMinutes) - (startHours * 60 + startMinutes);\n                } else {\n                    durationMinutes = (endHours * 60 + endMinutes) - (startHours * 60 + startMinutes);\n                }\n                \n                // Find the corresponding row in the filtered raw data\n                const rowIndex = updatedRawData.findIndex(row => \n                    row.datetime === `${timeslot.date} ${timeslot.start}` &&\n                    row.laakari === doctorName\n                );\n                \n                if (rowIndex !== -1) {\n                    // Update the existing row\n                    updatedRawData[rowIndex] = {\n                        ...updatedRawData[rowIndex],\n                        datetime: `${timeslot.date} ${timeslot.start}`,\n                        kesto_min: durationMinutes,\n                        tyhja: timeslot.isBooked ? 0 : 1,\n                        bookingProbability: timeslot.bookingProbability || 0.5\n                    };\n                } else {\n                    // The row was removed during filtering, add it back\n                    updatedRawData.push({\n                        datetime: `${timeslot.date} ${timeslot.start}`,\n                        laakari: doctorName,\n                        kesto_min: durationMinutes,\n                        tyhja: timeslot.isBooked ? 0 : 1,\n                        bookingProbability: timeslot.bookingProbability || 0.5\n                    });\n                }\n            } \n            // For new slots\n            else if (!originalData && timeslot.start && timeslot.end) {\n                // Calculate duration\n                const [startHours, startMinutes] = timeslot.start.split(':').map(Number);\n                const [endHours, endMinutes] = timeslot.end.split(':').map(Number);\n                \n                let durationMinutes;\n                if (endHours < startHours || (endHours === startHours && endMinutes < startMinutes)) {\n                    durationMinutes = ((endHours + 24) * 60 + endMinutes) - (startHours * 60 + startMinutes);\n                } else {\n                    durationMinutes = (endHours * 60 + endMinutes) - (startHours * 60 + startMinutes);\n                }\n                \n                // Create and add a new row\n                updatedRawData.push({\n                    datetime: `${timeslot.date} ${timeslot.start}`,\n                    laakari: doctorName,\n                    kesto_min: durationMinutes,\n                    tyhja: timeslot.isBooked ? 0 : 1,\n                    bookingProbability: timeslot.bookingProbability || 0.5,\n                    toimipiste: \"Default\",\n                    aikaryhman: \"Default\",\n                    aikaryhma: \"Default\",\n                    RESURSSI: \"Default\",\n                    specialty: \"Default\",\n                    ETNS_A: 1,\n                    ETNS_B: 1\n                });\n            }\n        });\n        \n        // Call the callback if provided\n        if (onDataChange) {\n            onDataChange(updatedRawData);\n        }\n\n        // Update Dash props if setProps is available\n        if (setProps) {\n            setProps({ rawData: updatedRawData });\n        }\n    }\n    \n    // Add these new methods for handling drag operations\n    handleDragStart(e, slot, type) {\n        e.stopPropagation();\n        if (slot.isBooked) return;\n        \n        // For move operations, capture the initial mouse position and offset\n        const initialMouseX = e.clientX;\n        let initialOffset = 0;\n        \n        if (type === 'move' && this.tableRef.current) {\n            const tableRect = this.tableRef.current.getBoundingClientRect();\n            // Calculate initial offset based on the position within the slot\n            const slotStart = this.timeToDecimal(slot.start) - this.props.startHour;\n            const hoursPerDay = this.props.endHour - this.props.startHour;\n            const pixelsPerHour = tableRect.width / hoursPerDay;\n            \n            // Calculate offset from the start of the slot in pixels\n            initialOffset = initialMouseX - (tableRect.left + slotStart * pixelsPerHour);\n        }\n        \n        this.setState({\n            isDragging: true,\n            dragType: type,\n            draggedSlot: slot,\n            originalSlot: { ...slot },\n            dragPreview: { ...slot }, // Start with original slot as preview for smoother transitions\n            initialMouseX,\n            initialOffset\n        });\n\n        document.addEventListener('mousemove', this.handleDrag);\n        document.addEventListener('mouseup', this.handleDragEnd);\n    }\n\n    handleDrag(e) {\n        if (!this.state.isDragging || !this.tableRef.current) return;\n\n        const { slotDuration, startHour, endHour } = this.props;\n        const { draggedSlot, dragType, initialOffset } = this.state;\n        \n        // If no draggedSlot is available, bail out early\n        if (!draggedSlot) return;\n\n        // Get accurate table dimensions\n        const tableRect = this.tableRef.current.getBoundingClientRect();\n        const hoursPerDay = endHour - startHour;\n        const pixelsPerHour = tableRect.width / hoursPerDay;\n        \n        // Calculate relative mouse position with offset adjustment for \"move\" operations\n        let relativeX;\n        if (dragType === 'move') {\n            relativeX = e.clientX - tableRect.left - initialOffset;\n        } else {\n            relativeX = e.clientX - tableRect.left;\n        }\n        \n        // Constrain the position to the table bounds\n        relativeX = Math.max(0, Math.min(relativeX, tableRect.width));\n        \n        // Convert pixel position to time\n        const hoursFromStart = relativeX / pixelsPerHour;\n        const totalHours = startHour + hoursFromStart;\n        \n        // Calculate hours and minutes, ensuring we have a valid hour (never negative)\n        const hour = Math.max(0, Math.floor(totalHours));\n        const minute = Math.floor((totalHours - hour) * 60);\n        \n        // Snap to grid\n        const snappedMinute = Math.round(minute / slotDuration) * slotDuration;\n        \n        // Ensure we don't end up with 60 minutes (should roll over to next hour)\n        const adjustedMinute = snappedMinute >= 60 ? 0 : snappedMinute;\n        const adjustedHour = snappedMinute >= 60 ? hour + 1 : hour;\n        \n        // Format the time string with guaranteed positive hours\n        const newTime = `${Math.min(23, Math.max(0, adjustedHour)).toString().padStart(2, '0')}:${adjustedMinute.toString().padStart(2, '0')}`;\n        \n        // Create a copy of the slot to update\n        const updatedSlot = { ...draggedSlot };\n        \n        if (dragType === 'move') {\n            // For moving, calculate duration and preserve it\n            const startDecimal = this.timeToDecimal(draggedSlot.start);\n            const endDecimal = this.timeToDecimal(draggedSlot.end);\n            const duration = endDecimal - startDecimal;\n            \n            // Set new start time based on grid-snapped position\n            updatedSlot.start = newTime;\n            \n            // Calculate new end time by adding the duration\n            const newEndDecimal = this.timeToDecimal(newTime) + duration;\n            // Using our decimalToTime helper, ensuring we validate the result\n            updatedSlot.end = this.decimalToTime(newEndDecimal);\n        } else if (dragType === 'start') {\n            // For resizing the start, ensure it doesn't go past the end\n            const endDecimal = this.timeToDecimal(draggedSlot.end);\n            const newStartDecimal = this.timeToDecimal(newTime);\n            \n            if (newStartDecimal < endDecimal) {\n                updatedSlot.start = newTime;\n            } else {\n                // If trying to drag start beyond end, cap it\n                updatedSlot.start = this.decimalToTime(endDecimal - (slotDuration / 60));\n            }\n        } else if (dragType === 'end') {\n            // For resizing the end, ensure it doesn't go before the start\n            const startDecimal = this.timeToDecimal(draggedSlot.start);\n            const newEndDecimal = this.timeToDecimal(newTime);\n            \n            if (newEndDecimal > startDecimal) {\n                updatedSlot.end = newTime;\n            } else {\n                // If trying to drag end before start, cap it\n                updatedSlot.end = this.decimalToTime(startDecimal + (slotDuration / 60));\n            }\n        }\n        \n        // Verify all time values are valid before updating state\n        if (this.isValidTime(updatedSlot.start) && this.isValidTime(updatedSlot.end)) {\n            this.setState({ dragPreview: updatedSlot });\n        }\n    }\n\n    // 2. Add this helper method to check if a time string is valid\n    isValidTime(timeString) {\n        if (!timeString) return false;\n        \n        // Check format and values\n        const timeRegex = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])$/;\n        if (!timeRegex.test(timeString)) return false;\n        \n        // Parse hours and minutes\n        const [hours, minutes] = timeString.split(':').map(Number);\n        \n        // Validate ranges\n        return hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60;\n    }\n\n    handleDragEnd(e) {\n        const { isDragging, dragPreview, draggedSlot, originalSlot, dragType } = this.state;\n        if (!isDragging || !draggedSlot) return;\n\n        document.removeEventListener('mousemove', this.handleDrag);\n        document.removeEventListener('mouseup', this.handleDragEnd);\n\n        // Store a reference to the slot we're working with\n        const slotId = draggedSlot.id;\n\n        // Add a flag to prevent right-click removal being triggered immediately after drag\n        // But only keep it briefly (100ms instead of 300ms)\n        this.justFinishedDragging = true;\n        setTimeout(() => {\n            this.justFinishedDragging = false;\n        }, 100);\n\n        if (dragPreview) {\n            const startTime = this.timeToDecimal(dragPreview.start);\n            const endTime = this.timeToDecimal(dragPreview.end);\n\n            if (endTime <= startTime) {\n                // Invalid time range, revert to original\n                this.setState({\n                    isDragging: false,\n                    dragType: null,\n                    draggedSlot: null,\n                    originalSlot: null,\n                    dragPreview: null\n                });\n                return;\n            }\n\n            // Update the slot with preview values\n            const { timeslots } = this.state;\n            \n            // Find the slot to update\n            const slotIndex = timeslots.findIndex(slot => slot.id === slotId);\n            \n            if (slotIndex !== -1) {\n                // Create a new array with the updated slot\n                const updatedTimeslots = [...timeslots];\n                updatedTimeslots[slotIndex] = {\n                    ...timeslots[slotIndex],\n                    start: dragPreview.start,\n                    end: dragPreview.end\n                };\n\n                this.setState({\n                    timeslots: updatedTimeslots,\n                    isDragging: false,\n                    dragType: null,\n                    draggedSlot: null,\n                    originalSlot: null,\n                    dragPreview: null\n                });\n\n                this.updateRawData(updatedTimeslots);\n            } else {\n                // If the slot wasn't found (shouldn't happen), just reset drag state\n                console.warn('Could not find slot to update:', slotId);\n                this.setState({\n                    isDragging: false,\n                    dragType: null,\n                    draggedSlot: null,\n                    originalSlot: null,\n                    dragPreview: null\n                });\n            }\n        } else {\n            // No drag preview, just reset state\n            this.setState({\n                isDragging: false,\n                dragType: null,\n                draggedSlot: null,\n                originalSlot: null,\n                dragPreview: null\n            });\n        }\n    }\n    \n    // Add these new methods for slot creation by dragging\n    handleCreationStart(e, professionalId, hour, minute) {\n        // Only proceed if left mouse button was clicked (button 0)\n        if (e.button !== 0) return;\n        \n        e.preventDefault();\n        e.stopPropagation();\n        \n        // Format the time for the creation start\n        const startTime = this.formatTime(hour, minute);\n        \n        this.setState({\n            isDragging: true,\n            dragType: 'create',\n            creationProfessionalId: professionalId,\n            creationStart: startTime,\n            creationEnd: startTime // Initially, end is same as start\n        });\n        \n        this.isCreatingSlot = true;\n        \n        // Add event listeners for drag and end\n        document.addEventListener('mousemove', this.handleCreationDrag);\n        document.addEventListener('mouseup', this.handleCreationEnd);\n    }\n\n    handleCreationDrag(e) {\n        if (!this.isCreatingSlot || !this.tableRef.current) return;\n        \n        const { slotDuration, startHour, endHour } = this.props;\n        const { creationStart } = this.state;\n        \n        // Get table dimensions\n        const tableRect = this.tableRef.current.getBoundingClientRect();\n        const hoursPerDay = endHour - startHour;\n        const pixelsPerHour = tableRect.width / hoursPerDay;\n        \n        // Calculate relative mouse position\n        const relativeX = e.clientX - tableRect.left;\n        \n        // Constrain the position to the table bounds\n        const boundedX = Math.max(0, Math.min(relativeX, tableRect.width));\n        \n        // Convert pixel position to time\n        const hoursFromStart = boundedX / pixelsPerHour;\n        const totalHours = startHour + hoursFromStart;\n        \n        // Calculate hours and minutes, ensuring we have a valid hour (never negative)\n        const hour = Math.max(0, Math.floor(totalHours));\n        const minute = Math.floor((totalHours - hour) * 60);\n        \n        // Snap to grid\n        const snappedMinute = Math.round(minute / slotDuration) * slotDuration;\n        \n        // Ensure we don't end up with 60 minutes (should roll over to next hour)\n        const adjustedMinute = snappedMinute >= 60 ? 0 : snappedMinute;\n        const adjustedHour = snappedMinute >= 60 ? hour + 1 : hour;\n        \n        // Format the time string with guaranteed positive hours\n        const newTime = `${Math.min(23, Math.max(0, adjustedHour)).toString().padStart(2, '0')}:${adjustedMinute.toString().padStart(2, '0')}`;\n        \n        // Update the end time\n        this.setState({ creationEnd: newTime });\n    }\n\n    handleCreationEnd(e) {\n        if (!this.isCreatingSlot) return;\n        \n        // Clean up event listeners\n        document.removeEventListener('mousemove', this.handleCreationDrag);\n        document.removeEventListener('mouseup', this.handleCreationEnd);\n        \n        const { creationStart, creationEnd, creationProfessionalId } = this.state;\n        \n        // Sort the times to ensure start is before end\n        let startTime = creationStart;\n        let endTime = creationEnd;\n        \n        // Convert to decimal for comparison\n        const startDecimal = this.timeToDecimal(startTime);\n        const endDecimal = this.timeToDecimal(endTime);\n        \n        // If they're dragging backwards, swap the times\n        if (endDecimal < startDecimal) {\n            [startTime, endTime] = [endTime, startTime];\n        }\n        \n        // Only create a slot if the times are different\n        if (startTime !== endTime) {\n            const { timeslots, date } = this.state;\n            \n            // Create new slot\n            const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\n            const slotToAdd = {\n                id: newId,\n                professionalId: creationProfessionalId,\n                start: startTime,\n                end: endTime,\n                date: date,\n                bookingProbability: 0.5,\n                isBooked: false,\n                appointmentType: 'In-person appointment',\n                resource: 'Default',\n                rawData: null // New slot has no original data\n            };\n            \n            // Update timeslots and raw data\n            const updatedTimeslots = [...timeslots, slotToAdd];\n            this.setState({ \n                timeslots: updatedTimeslots,\n                isDragging: false,\n                dragType: null,\n                creationStart: null,\n                creationEnd: null,\n                creationProfessionalId: null\n            });\n            \n            this.updateRawData(updatedTimeslots);\n        } else {\n            // If start and end are the same, just reset the state\n            this.setState({\n                isDragging: false,\n                dragType: null,\n                creationStart: null,\n                creationEnd: null,\n                creationProfessionalId: null\n            });\n        }\n        \n        this.isCreatingSlot = false;\n    }\n    \n    // 1. First, add componentWillUnmount to clean up event listeners\n    componentWillUnmount() {\n        // Clean up event listeners\n        document.removeEventListener('mousemove', this.handleDrag);\n        document.removeEventListener('mouseup', this.handleDragEnd);\n        document.removeEventListener('mousemove', this.handleCreationDrag);\n        document.removeEventListener('mouseup', this.handleCreationEnd);\n    }\n    \n    // Add this utility method to reset all drag-related state\n    resetDragState() {\n        // Clean up all event listeners\n        document.removeEventListener('mousemove', this.handleDrag);\n        document.removeEventListener('mouseup', this.handleDragEnd);\n        document.removeEventListener('mousemove', this.handleCreationDrag);\n        document.removeEventListener('mouseup', this.handleCreationEnd);\n        \n        // Reset all drag-related state\n        this.setState({\n            isDragging: false,\n            dragType: null,\n            draggedSlot: null,\n            originalSlot: null,\n            dragPreview: null,\n            creationStart: null,\n            creationEnd: null,\n            creationProfessionalId: null\n        });\n        \n        // Reset flags\n        this.isCreatingSlot = false;\n        this.justFinishedDragging = false;\n    }\n    \n    render() {\n        const { id, date, startHour, endHour, slotDuration, backgroundColor } = this.props;\n        const { professionals, timeslots } = this.state;\n        \n        // Calculate number of time slots per hour (e.g., 12 for 5-minute slots)\n        const slotsPerHour = 60 / slotDuration;\n        \n        // Calculate total number of slots in the timeline\n        const totalSlots = (endHour - startHour) * slotsPerHour;\n        \n        // Calculate a reasonable cell width in pixels - each hour should be at least 60px wide\n        const hourWidth = 60;\n        const cellWidth = hourWidth / slotsPerHour;\n        \n        const styles = {\n            dashGantt: {\n                fontFamily: 'Arial, sans-serif',\n                margin: '20px 0'\n            },\n            dashGanttHeader: {\n                marginBottom: '10px'\n            },\n            dashGanttContainer: {\n                border: '1px solid #e0e0e0', // Even lighter border for simple_white theme\n                borderRadius: '4px', // Less rounded corners for clean look\n                overflow: 'hidden',\n                overflowX: 'auto',\n                boxShadow: 'none' // No shadow for minimalist look\n            },\n            dashGanttTable: {\n                width: '100%',\n                borderCollapse: 'collapse',\n                tableLayout: 'fixed',\n                // Each hour is at least hourWidth pixels, plus professional column\n                minWidth: `${150 + (endHour - startHour) * hourWidth}px`\n            },\n            dashGanttHeaderRow: {\n                backgroundColor: backgroundColor || '#ffffff' // White background like simple_white theme\n            },\n            dashGanttHeaderCell: {\n                padding: '12px 8px', \n                textAlign: 'center',\n                fontWeight: '500',\n                borderRight: '1px solid #eaeaea',\n                borderBottom: '1px solid #eaeaea',\n                fontSize: '14px',\n                color: '#444',\n                position: 'relative'\n            },\n            dashGanttFirstHeaderCell: {\n                width: '150px',\n                borderRight: '1px solid #eaeaea', // Changed from #aaaaaa to match other cells\n                borderBottom: '1px solid #eaeaea'\n            },\n            dashGanttRow: {\n                height: '60px'\n            },\n            dashGanttProfessionalCell: {\n                width: '150px',\n                padding: '8px',\n                borderRight: '1px solid #eaeaea',\n                borderBottom: '1px solid #eaeaea',\n                backgroundColor: backgroundColor || '#ffffff',\n                verticalAlign: 'middle',\n                fontWeight: '500',\n                fontSize: '14px',\n                color: '#444'\n            },\n            dashGanttTimeCell: {\n                position: 'relative',\n                padding: '0',\n                borderRight: '1px solid #f5f5f5', // Very subtle grid lines\n                borderBottom: '1px solid #eaeaea',\n                cursor: 'pointer',\n                height: '60px',\n                // We're setting a minimum width based on a reasonable cell size\n                minWidth: '5px', \n                width: `${100 / totalSlots}%`,\n                boxSizing: 'border-box',\n                transition: 'background-color 0.2s ease'\n            },\n            dashGanttSlot: {\n                position: 'absolute',\n                top: '0',\n                height: '100%',\n                backgroundColor: '#4CAF50',\n                color: 'white',\n                borderRadius: '4px',\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                cursor: 'pointer',\n                boxShadow: '0 1px 3px rgba(0,0,0,0.1)', // Lighter shadow for cleaner look\n                zIndex: 10,\n                overflow: 'hidden'\n            },\n            dashGanttProbability: {\n                fontSize: '14px',\n                fontWeight: '500'\n            },\n            dashGanttEditor: {\n                marginTop: '20px',\n                padding: '15px',\n                border: '1px solid #eaeaea', // Lighter border for simple_white\n                borderRadius: '4px',\n                backgroundColor: '#ffffff' // Pure white background\n            },\n            dashGanttForm: {\n                display: 'flex',\n                flexDirection: 'column',\n                gap: '10px'\n            },\n            dashGanttFormGroup: {\n                display: 'flex',\n                alignItems: 'center'\n            },\n            dashGanttFormGroupLabel: {\n                width: '100px',\n                marginRight: '10px',\n                color: '#444',\n                fontSize: '14px'\n            },\n            dashGanttFormGroupInput: {\n                flex: 1,\n                padding: '8px',\n                border: '1px solid #eaeaea',\n                borderRadius: '4px',\n                fontSize: '14px'\n            },\n            dashGanttFormActions: {\n                display: 'flex',\n                gap: '10px',\n                marginTop: '10px'\n            },\n            dashGanttFormActionsButton: {\n                padding: '8px 15px',\n                border: 'none',\n                borderRadius: '4px',\n                cursor: 'pointer',\n                fontWeight: '500',\n                fontSize: '14px'\n            },\n            dashGanttFormActionsSave: {\n                backgroundColor: '#2196F3', // Using blue for primary action\n                color: 'white'\n            },\n            dashGanttFormActionsCancel: {\n                backgroundColor: '#f5f5f5',\n                color: '#333'\n            },\n            dashGanttFormActionsRemove: {\n                backgroundColor: '#f44336',\n                color: 'white'\n            }\n        };\n        \n        // Generate hour labels\n        const hourLabels = [];\n        for (let hour = startHour; hour <= endHour; hour++) {\n            const displayHour = hour % 24; // Handle 24-hour format\n            const isPM = displayHour >= 12;\n            const display12Hour = displayHour === 0 ? 12 : (displayHour > 12 ? displayHour - 12 : displayHour);\n            const timeLabel = `${display12Hour}${isPM ? 'PM' : 'AM'}`;\n            hourLabels.push(timeLabel);\n        }\n        \n        // Generate hour header cells\n        const generateHourHeaderCells = () => {\n            const cells = [];\n            \n            for (let hour = startHour; hour <= endHour; hour++) {\n                // Use 24-hour format (European style)\n                // Ensure we're not exceeding 24 hours (handle edge case for endHour=24)\n                const displayHour = hour === 24 ? 24 : hour % 24;\n                // Format as 2-digit hour (e.g., \"06\" instead of \"6\")\n                const timeLabel = `${displayHour.toString().padStart(2, '0')}:00`;\n                \n                // Remove the left border that we previously added\n                cells.push(\n                    <th \n                        key={`header-${hour}`} \n                        colSpan={slotsPerHour}\n                        style={styles.dashGanttHeaderCell}\n                    >\n                        {timeLabel}\n                    </th>\n                );\n            }\n            \n            return cells;\n        };\n\n        return (\n            <div id={id} style={styles.dashGantt}>\n                <div style={styles.dashGanttHeader}>\n                    <h2>Schedule for {date}</h2>\n                </div>\n                <div style={styles.dashGanttContainer}>\n                    <table ref={this.tableRef} style={styles.dashGanttTable}>\n                        <thead>\n                            <tr style={styles.dashGanttHeaderRow}>\n                                <th style={styles.dashGanttFirstHeaderCell}></th>\n                                {generateHourHeaderCells()}\n                            </tr>\n                        </thead>\n                        <tbody>\n                            {professionals.map(professional => (\n                                <tr key={`row-${professional.id}`} style={styles.dashGanttRow}>\n                                    <td style={styles.dashGanttProfessionalCell}>\n                                        {professional.name}\n                                    </td>\n                                    {this.generateTimeCells(professional, styles)}\n                                </tr>\n                            ))}\n                        </tbody>\n                    </table>\n                </div>\n                \n                {/* Render slot editor */}\n                {this.state.selectedSlot || this.state.isAddingSlot ? (\n                    <div style={styles.dashGanttEditor}>\n                        <h3>{this.state.isAddingSlot ? 'Add New Slot' : 'Edit Slot'}</h3>\n                        <div style={styles.dashGanttForm}>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>Professional:</label>\n                                <select \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.professionalId : this.state.selectedSlot.professionalId} \n                                    onChange={e => {\n                                        const professionalId = parseInt(e.target.value);\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, professionalId } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, professionalId } });\n                                        }\n                                    }}\n                                    disabled={!this.state.isAddingSlot}\n                                >\n                                    {professionals.map(p => (\n                                        <option key={p.id} value={p.id}>{p.name}</option>\n                                    ))}\n                                </select>\n                            </div>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>Start Time:</label>\n                                <input \n                                    type=\"time\" \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.start : this.state.selectedSlot.start} \n                                    onChange={e => {\n                                        const start = e.target.value;\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, start } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, start } });\n                                        }\n                                    }}\n                                />\n                            </div>\n                            <div style={styles.dashGanttFormGroup}>\n                                <label style={styles.dashGanttFormGroupLabel}>End Time:</label>\n                                <input \n                                    type=\"time\" \n                                    style={styles.dashGanttFormGroupInput}\n                                    value={this.state.isAddingSlot ? this.state.newSlot.end : this.state.selectedSlot.end} \n                                    onChange={e => {\n                                        const end = e.target.value;\n                                        if (this.state.isAddingSlot) {\n                                            this.setState({ newSlot: { ...this.state.newSlot, end } });\n                                        } else {\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, end } });\n                                        }\n                                    }}\n                                />\n                            </div>\n                            <div style={styles.dashGanttFormActions}>\n                                <button \n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsSave}}\n                                    onClick={this.handleSaveSlot}\n                                >\n                                    Save\n                                </button>\n                                <button \n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsCancel}}\n                                    onClick={this.handleCancelEdit}\n                                >\n                                    Cancel\n                                </button>\n                                {!this.state.isAddingSlot && (\n                                    <button \n                                        style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsRemove}}\n                                        onClick={() => this.handleRemoveSlot(this.state.selectedSlot.id)}\n                                    >\n                                        Remove\n                                    </button>\n                                )}\n                            </div>\n                        </div>\n                    </div>\n                ) : null}\n            </div>\n        );\n    }\n}\n\nDashGantt.defaultProps = {\n    rawData: [],\n    date: new Date().toISOString().split('T')[0],\n    startHour: 6,\n    endHour: 23,\n    slotDuration: 5,\n    backgroundColor: '#f5f5f5',\n    onDataChange: null\n};\n\nDashGantt.propTypes = {\n    id: PropTypes.string,\n    rawData: PropTypes.arrayOf(\n        PropTypes.shape({\n            datetime: PropTypes.string.isRequired,\n            laakari: PropTypes.string.isRequired,\n            kesto_min: PropTypes.number.isRequired,\n            tyhja: PropTypes.number.isRequired\n        })\n    ),\n    date: PropTypes.string,\n    startHour: PropTypes.number,\n    endHour: PropTypes.number,\n    slotDuration: PropTypes.number,\n    backgroundColor: PropTypes.string,\n    onDataChange: PropTypes.func,\n    setProps: PropTypes.func\n};\n"],"names":["DashGantt","_Component","props","_this","_classCallCheck","_callSuper","tableRef","React","justFinishedDragging","isCreatingSlot","rawData","date","_DashGantt$transformD","transformData","Date","toISOString","split","professionals","timeslots","state","selectedSlot","isAddingSlot","newSlot","professionalId","start","end","hoveredCell","slotWidthCache","isDragging","dragSide","draggedSlot","originalSlot","dragPreview","dragType","creationStart","creationEnd","creationProfessionalId","handleSlotClick","bind","handleAddSlot","handleCreateSlot","handleRemoveSlot","handleSaveSlot","handleCancelEdit","handleCellHover","handleCellLeave","renderSlotRectangle","generateTimeCells","formatTime","timeToDecimal","calculateSlotWidth","getSlotWidth","updateRawData","handleDragStart","handleDrag","handleDragEnd","handleCreationStart","handleCreationDrag","handleCreationEnd","_inherits","key","value","_this$props","this","_DashGantt$transformD2","setState","slot","hour","minute","currentHover","_this$state","startHour","Math","floor","startMinutes","startTime","concat","toString","padStart","totalEndMinutes","endHour","endMinutes","endTime","slotToAdd","id","length","max","apply","_toConsumableArray","map","bookingProbability","isBooked","appointmentType","resource","updatedTimeslots","slotDuration","endTimeInMinutes","slotId","resetDragState","filter","_this$state2","_objectSpread","timeStr","_timeStr$split$map2","_slicedToArray","Number","startDecimal","durationInMinutes","numCells","round","decimal","wrappedDecimal","hours","minutes","adjustedMinutes","probability","undefined","p","min","colorPalette","_this2","numCellsToSpan","slotStyle","position","top","left","height","width","boxSizing","backgroundColor","getProbabilityColor","color","borderRadius","display","justifyContent","alignItems","cursor","boxShadow","zIndex","transition","opacity","handleStyle","bottom","leftHandleStyle","rightHandleStyle","right","invisibleHandleStyle","leftInvisibleHandleStyle","rightInvisibleHandleStyle","style","onClick","e","stopPropagation","onMouseDown","target","currentTarget","button","onContextMenu","preventDefault","title","onMouseEnter","onMouseLeave","visibleHandle","previousSibling","error","console","professional","styles","_this3","_this$props2","_this$state3","slotsPerHour","cells","professionalSlots","slotsByStartTime","forEach","_slot$start$split$map2","isPreviewingForThisProfessional","slotBeingDragged","isCreatingForThisProfessional","creationStartDecimal","creationEndDecimal","_ref2","_loop","_loop2","cellContent","minuteIndex","timeKey","displayTimeKey","isHovered","timeDisplay","cellStyle","dashGanttTimeCell","cellTimeDecimal","isInPreviewRange","isInCreationRange","border","pointerEvents","fontSize","padding","push","cacheKey","nextProps","nextState","prevProps","_this4","_this$props3","onDataChange","setProps","updatedRawData","validTimeslots","Set","_this4$state$professi","doctorName","find","name","add","item","datetime","laakari","has","timeslot","_this4$state$professi2","isValidTime","originalData","durationMinutes","_timeslot$start$split2","startHours","_timeslot$end$split$m2","endHours","rowIndex","findIndex","row","kesto_min","tyhja","_timeslot$start$split4","_timeslot$end$split$m4","toimipiste","aikaryhman","aikaryhma","RESURSSI","specialty","ETNS_A","ETNS_B","warn","type","initialMouseX","clientX","initialOffset","current","tableRect","getBoundingClientRect","slotStart","hoursPerDay","pixelsPerHour","document","addEventListener","_this$props4","_this$state4","relativeX","totalHours","snappedMinute","adjustedMinute","adjustedHour","newTime","updatedSlot","duration","newEndDecimal","decimalToTime","endDecimal","newStartDecimal","timeString","test","_timeString$split$map2","_this5","_this$state5","removeEventListener","setTimeout","slotIndex","_this$props5","_this$state6","_ref3","_this$state7","_this6","_this$props6","_this$state8","totalSlots","dashGantt","fontFamily","margin","dashGanttHeader","marginBottom","dashGanttContainer","overflow","overflowX","dashGanttTable","borderCollapse","tableLayout","minWidth","dashGanttHeaderRow","dashGanttHeaderCell","textAlign","fontWeight","borderRight","borderBottom","dashGanttFirstHeaderCell","dashGanttRow","dashGanttProfessionalCell","verticalAlign","dashGanttSlot","dashGanttProbability","dashGanttEditor","marginTop","dashGanttForm","flexDirection","gap","dashGanttFormGroup","dashGanttFormGroupLabel","marginRight","dashGanttFormGroupInput","flex","dashGanttFormActions","dashGanttFormActionsButton","dashGanttFormActionsSave","dashGanttFormActionsCancel","dashGanttFormActionsRemove","hourLabels","displayHour","isPM","timeLabel","ref","colSpan","generateHourHeaderCells","onChange","parseInt","disabled","filteredData","Array","from","doctor","idx","doctorToId","Object","fromEntries","_row$datetime$split2","time","_time$split$map2","startDate","setHours","endDate","getTime","getHours","getMinutes","prevState","_DashGantt$transformD3","Component","defaultProps","propTypes","PropTypes","isRequired"],"sourceRoot":""}