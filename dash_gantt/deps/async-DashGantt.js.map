{"version":3,"file":"async-DashGantt.js","mappings":"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","sources":["webpack:///./src/lib/fragments/DashGantt.react.js"],"sourcesContent":["import React, {Component} from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n/**\r\n * DashGantt is a Gantt chart component for scheduling.\r\n * It displays professionals vertically and time horizontally.\r\n * Users can add, modify, and remove timeslots for each professional.\r\n * The component outputs data that can be used in a prediction model.\r\n */\r\nexport default class DashGantt extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        \r\n        // Initialize state with props\r\n        const { rawData, date } = props;\r\n        const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || new Date().toISOString().split('T')[0]);\r\n        \r\n        this.state = {\r\n            selectedSlot: null,\r\n            isAddingSlot: false,\r\n            newSlot: {\r\n                professionalId: null,\r\n                start: null,\r\n                end: null\r\n            },\r\n            hoveredCell: null,\r\n            // Cache for slot width calculations to avoid repeated calculations\r\n            slotWidthCache: {},\r\n            // Internal state for transformed data\r\n            professionals: professionals || [],\r\n            timeslots: timeslots || [],\r\n            rawData: rawData || [],\r\n            date: date || new Date().toISOString().split('T')[0]\r\n        };\r\n        \r\n        // Bind methods\r\n        this.handleSlotClick = this.handleSlotClick.bind(this);\r\n        this.handleAddSlot = this.handleAddSlot.bind(this);\r\n        this.handleCreateSlot = this.handleCreateSlot.bind(this);\r\n        this.handleRemoveSlot = this.handleRemoveSlot.bind(this);\r\n        this.handleSaveSlot = this.handleSaveSlot.bind(this);\r\n        this.handleCancelEdit = this.handleCancelEdit.bind(this);\r\n        this.handleCellHover = this.handleCellHover.bind(this);\r\n        this.handleCellLeave = this.handleCellLeave.bind(this);\r\n        this.renderSlotRectangle = this.renderSlotRectangle.bind(this);\r\n        this.generateTimeCells = this.generateTimeCells.bind(this);\r\n        this.formatTime = this.formatTime.bind(this);\r\n        this.timeToDecimal = this.timeToDecimal.bind(this);\r\n        this.calculateSlotWidth = this.calculateSlotWidth.bind(this);\r\n        this.getSlotWidth = this.getSlotWidth.bind(this);\r\n        this.updateRawData = this.updateRawData.bind(this);\r\n    }\r\n    \r\n    // Transform raw data into component format\r\n    static transformData(rawData, date) {\r\n        if (!rawData || !date) return { professionals: [], timeslots: [] };\r\n\r\n        // Filter data for the specific date\r\n        const filteredData = rawData.filter(row => {\r\n            const rowDate = row.datetime.split(' ')[0];\r\n            return rowDate === date;\r\n        });\r\n\r\n        // Create professionals list from unique doctors\r\n        const professionals = Array.from(new Set(filteredData.map(row => row.laakari)))\r\n            .map((doctor, idx) => ({ id: idx + 1, name: doctor }));\r\n\r\n        // Create doctor to id mapping\r\n        const doctorToId = Object.fromEntries(\r\n            professionals.map((p, idx) => [p.name, idx + 1])\r\n        );\r\n\r\n        // Transform timeslots\r\n        const timeslots = filteredData.map((row, idx) => {\r\n            const [date, time] = row.datetime.split(' ');\r\n            const startTime = time;\r\n            \r\n            // Calculate end time based on duration\r\n            const [hours, minutes] = time.split(':').map(Number);\r\n            const startDate = new Date();\r\n            startDate.setHours(hours, minutes, 0);\r\n            // Use kesto_min directly from the data\r\n            const durationMinutes = row.kesto_min || 0;\r\n            const endDate = new Date(startDate.getTime() + durationMinutes * 60000);\r\n            const endTime = `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;\r\n\r\n            return {\r\n                id: idx + 1,\r\n                professionalId: doctorToId[row.laakari],\r\n                start: startTime,\r\n                end: endTime,\r\n                date: date,\r\n                durationMinutes: durationMinutes, // Store the original duration\r\n                bookingProbability: row.bookingProbability || 0.5,\r\n                isBooked: row.tyhja === 0,\r\n                rawData: row // Keep reference to original data with all fields\r\n            };\r\n        });\r\n\r\n        return { professionals, timeslots };\r\n    }\r\n    \r\n    // Update getDerivedStateFromProps to handle undefined values\r\n    static getDerivedStateFromProps(nextProps, prevState) {\r\n        if (!nextProps) return null;\r\n        \r\n        const { rawData, date } = nextProps;\r\n        if (rawData !== prevState.rawData || date !== prevState.date) {\r\n            const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || prevState.date);\r\n            return { \r\n                professionals: professionals || [], \r\n                timeslots: timeslots || [], \r\n                rawData: rawData || [], \r\n                date: date || prevState.date \r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Update componentDidMount to handle undefined values\r\n    componentDidMount() {\r\n        const { rawData, date } = this.props;\r\n        const { professionals, timeslots } = DashGantt.transformData(rawData || [], date || this.state.date);\r\n        this.setState({ \r\n            professionals: professionals || [], \r\n            timeslots: timeslots || [],\r\n            rawData: rawData || [],\r\n            date: date || this.state.date\r\n        });\r\n    }\r\n    \r\n    // Handle clicking on a timeslot\r\n    handleSlotClick(slot) {\r\n        this.setState({\r\n            selectedSlot: slot,\r\n            isAddingSlot: false\r\n        });\r\n    }\r\n    \r\n    // Handle cell hover\r\n    handleCellHover(professionalId, hour, minute) {\r\n        // Avoid unnecessary state updates if hovering over the same cell\r\n        const currentHover = this.state.hoveredCell;\r\n        if (currentHover && \r\n            currentHover.professionalId === professionalId && \r\n            currentHover.hour === hour && \r\n            currentHover.minute === minute) {\r\n            return; // No change needed\r\n        }\r\n        \r\n        // Update the hover state\r\n        this.setState({\r\n            hoveredCell: { professionalId, hour, minute }\r\n        });\r\n    }\r\n    \r\n    // Handle cell leave\r\n    handleCellLeave() {\r\n        // Only update state if we're currently hovering over a cell\r\n        if (this.state.hoveredCell !== null) {\r\n            this.setState({\r\n                hoveredCell: null\r\n            });\r\n        }\r\n    }\r\n    \r\n    // Handle creating a new timeslot with a single click\r\n    handleCreateSlot(professionalId, hour, minute) {\r\n        const { timeslots, date } = this.state;\r\n        \r\n        // Calculate start and end times\r\n        const startHour = Math.floor(hour);\r\n        const startMinutes = minute;\r\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\r\n        \r\n        // Always create a 20-minute slot as per business requirements\r\n        const slotDurationMinutes = 20;\r\n        \r\n        // Calculate end time\r\n        const totalStartMinutes = (startHour * 60) + startMinutes;\r\n        const totalEndMinutes = totalStartMinutes + slotDurationMinutes;\r\n        const endHour = Math.floor(totalEndMinutes / 60);\r\n        const endMinutes = totalEndMinutes % 60;\r\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\r\n        \r\n        // Create new slot\r\n        const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\r\n        const slotToAdd = {\r\n            id: newId,\r\n            professionalId: professionalId,\r\n            start: startTime,\r\n            end: endTime,\r\n            date: date,\r\n            bookingProbability: 0.5,\r\n            isBooked: false,\r\n            appointmentType: 'In-person appointment',\r\n            resource: 'Default',\r\n            rawData: null // New slot has no original data\r\n        };\r\n        \r\n        // Update timeslots and raw data\r\n        const updatedTimeslots = [...timeslots, slotToAdd];\r\n        this.setState({ timeslots: updatedTimeslots });\r\n        this.updateRawData(updatedTimeslots);\r\n    }\r\n    \r\n    // Handle adding a new timeslot\r\n    handleAddSlot(professionalId, hour, minute) {\r\n        const { slotDuration } = this.props;\r\n        const startHour = Math.floor(hour);\r\n        const startMinutes = minute;\r\n        const startTime = `${startHour.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;\r\n        \r\n        const endTimeInMinutes = startHour * 60 + startMinutes + slotDuration;\r\n        const endHour = Math.floor(endTimeInMinutes / 60);\r\n        const endMinutes = endTimeInMinutes % 60;\r\n        const endTime = `${endHour.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;\r\n        \r\n        this.setState({\r\n            isAddingSlot: true,\r\n            selectedSlot: null,\r\n            newSlot: {\r\n                professionalId,\r\n                start: startTime,\r\n                end: endTime\r\n            }\r\n        });\r\n    }\r\n    \r\n    // Handle removing a timeslot\r\n    handleRemoveSlot(slotId) {\r\n        const { timeslots } = this.state;\r\n        const updatedTimeslots = timeslots.filter(slot => slot.id !== slotId);\r\n        this.setState({ \r\n            timeslots: updatedTimeslots,\r\n            selectedSlot: null\r\n        });\r\n        this.updateRawData(updatedTimeslots);\r\n    }\r\n    \r\n    // Handle saving a timeslot (new or edited)\r\n    handleSaveSlot() {\r\n        const { timeslots } = this.state;\r\n        const { selectedSlot, newSlot, isAddingSlot } = this.state;\r\n        \r\n        let updatedTimeslots;\r\n        \r\n        if (isAddingSlot) {\r\n            // Add new slot\r\n            const newId = timeslots.length > 0 ? Math.max(...timeslots.map(slot => slot.id)) + 1 : 1;\r\n            const slotToAdd = {\r\n                id: newId,\r\n                professionalId: newSlot.professionalId,\r\n                start: newSlot.start,\r\n                end: newSlot.end,\r\n                date: this.props.date,\r\n                bookingProbability: 0.5,\r\n                isBooked: false,\r\n                appointmentType: 'In-person appointment',\r\n                resource: 'Default',\r\n                rawData: null\r\n            };\r\n            \r\n            updatedTimeslots = [...timeslots, slotToAdd];\r\n        } else {\r\n            // Update existing slot\r\n            updatedTimeslots = timeslots.map(slot => \r\n                slot.id === selectedSlot.id ? { ...slot, ...selectedSlot } : slot\r\n            );\r\n        }\r\n        \r\n        this.setState({\r\n            timeslots: updatedTimeslots,\r\n            selectedSlot: null,\r\n            isAddingSlot: false,\r\n            newSlot: {\r\n                professionalId: null,\r\n                start: null,\r\n                end: null\r\n            }\r\n        });\r\n        \r\n        this.updateRawData(updatedTimeslots);\r\n    }\r\n    \r\n    // Handle canceling edit or add operation\r\n    handleCancelEdit() {\r\n        this.setState({\r\n            selectedSlot: null,\r\n            isAddingSlot: false,\r\n            newSlot: {\r\n                professionalId: null,\r\n                start: null,\r\n                end: null\r\n            }\r\n        });\r\n    }\r\n    \r\n    // Convert time string to decimal hours\r\n    timeToDecimal(timeStr) {\r\n        const [hours, minutes] = timeStr.split(':').map(Number);\r\n        return hours + (minutes / 60);\r\n    }\r\n    \r\n    // Calculate the width of a slot that should span multiple cells\r\n    calculateSlotWidth(start, end, slotDuration) {\r\n        // Calculate duration in minutes\r\n        const startDecimal = this.timeToDecimal(start);\r\n        const endDecimal = this.timeToDecimal(end);\r\n        const durationInHours = endDecimal - startDecimal;\r\n        const durationInMinutes = durationInHours * 60;\r\n        \r\n        // Calculate how many grid cells this should span\r\n        // To avoid floating-point precision issues, round to the nearest integer\r\n        // For a 20-minute duration with 5-minute slots, this should consistently give 4 cells\r\n        const numCells = Math.round(durationInMinutes / slotDuration);\r\n        \r\n        // Log the calculation only in development mode to reduce console noise\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.log(`Slot ${start}-${end}: Duration=${durationInMinutes}min, Spans ${numCells} cells`);\r\n        }\r\n        \r\n        // Return the exact number of cells to span (minimum 1)\r\n        return Math.max(1, numCells);\r\n    }\r\n    \r\n    // Format decimal hours to time string\r\n    decimalToTime(decimal) {\r\n        const hours = Math.floor(decimal);\r\n        const minutes = Math.round((decimal - hours) * 60);\r\n        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\r\n    }\r\n    \r\n    // Get color based on booking probability and booking status\r\n    getProbabilityColor(slot) {\r\n        // If the slot is booked, use a gray color\r\n        if (slot.isBooked) {\r\n            return '#808080'; // Gray color for booked slots\r\n        }\r\n        \r\n        // For unbooked slots, use probability-based colors from the provided palette\r\n        const probability = slot.bookingProbability;\r\n        if (probability === undefined) return 'rgb(0, 147, 146)'; // Default to first color in palette\r\n        \r\n        // Clamp probability between 0 and 1 for safety\r\n        const p = Math.max(0, Math.min(1, probability));\r\n        \r\n        // Define the color palette (from green to red)\r\n        const colorPalette = [\r\n            \"rgb(0, 147, 146)\",    // First green\r\n            \"rgb(57, 177, 133)\",\r\n            \"rgb(156, 203, 134)\",\r\n            \"rgb(233, 226, 156)\",  // Yellow-ish\r\n            \"rgb(238, 180, 121)\",\r\n            \"rgb(232, 132, 113)\",\r\n            \"rgb(207, 89, 126)\"    // Last red\r\n        ];\r\n        \r\n        // Calculate which color to use based on probability\r\n        // p=0 means highest index (most red), p=1 means lowest index (most green)\r\n        const index = Math.floor((1 - p) * (colorPalette.length - 1));\r\n        \r\n        return colorPalette[index];\r\n    }\r\n    \r\n    // Render a single slot rectangle\r\n    renderSlotRectangle(slot) {\r\n        if (!slot) return null;\r\n        \r\n        const { slotDuration } = this.props || {};\r\n        if (!slotDuration) return null;\r\n        \r\n        try {\r\n            // Get the number of cells this slot should span (using cached value if available)\r\n            const numCellsToSpan = this.getSlotWidth(slot, slotDuration);\r\n            \r\n            // We need to make the rectangle fill exactly the grid cells it should span\r\n            // Calculate width to exactly fill the grid cells\r\n            const slotStyle = {\r\n                position: 'absolute',\r\n                top: '2px',\r\n                left: '0',\r\n                height: 'calc(100% - 4px)',\r\n                // For a consistent calculation that accounts for grid lines:\r\n                // - Multiply by 100% to get the percentage width\r\n                // - Add (numCells-1) pixels to account for the internal borders\r\n                width: `calc(${numCellsToSpan * 100}% + ${numCellsToSpan - 1}px)`,\r\n                // Set box-sizing to border-box to include borders in element's dimensions\r\n                boxSizing: 'border-box',\r\n                backgroundColor: this.getProbabilityColor(slot),\r\n                color: 'white',\r\n                borderRadius: '0', // Remove rounded corners\r\n                display: 'flex',\r\n                justifyContent: 'center',\r\n                alignItems: 'center',\r\n                cursor: slot.isBooked ? 'not-allowed' : 'pointer',\r\n                boxShadow: '0 1px 2px rgba(0,0,0,0.1)', // Lighter shadow for simple_white theme\r\n                zIndex: 100,\r\n                transition: 'all 0.15s ease-in-out',\r\n                opacity: slot.isBooked ? 0.8 : 1\r\n            };\r\n            \r\n            return (\r\n                <div \r\n                    key={`slot-${slot.id}`} \r\n                    style={slotStyle}\r\n                    onClick={(e) => {\r\n                        e.stopPropagation();\r\n                        if (!slot.isBooked) {\r\n                            this.handleSlotClick(slot);\r\n                        }\r\n                    }}\r\n                    onContextMenu={(e) => {\r\n                        e.preventDefault();  // Prevent the default context menu\r\n                        e.stopPropagation();\r\n                        if (!slot.isBooked) {\r\n                            this.handleRemoveSlot(slot.id);\r\n                        }\r\n                    }}\r\n                    title={`Time slot: ${slot.start} - ${slot.end}\r\n${slot.isBooked ? 'Status: Booked' : `Booking probability: ${Math.round((slot.bookingProbability || 0.5) * 100)}%`}`}\r\n                >\r\n                </div>\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error rendering slot rectangle:\", error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    // Format time for display (HH:MM)\r\n    formatTime(hour, minute) {\r\n        return `${Math.floor(hour).toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\r\n    }\r\n    \r\n    // Generate time cells for each hour and minute interval\r\n    generateTimeCells(professional, styles) {\r\n        const { startHour, endHour, slotDuration } = this.props;\r\n        const { timeslots } = this.state; // Use state timeslots instead of props\r\n        const slotsPerHour = 60 / slotDuration;\r\n        const cells = [];\r\n        \r\n        // Only filter slots for this professional once\r\n        const professionalSlots = timeslots.filter(slot => slot.professionalId === professional.id);\r\n        \r\n        // Group slots by their start time for more efficient lookup\r\n        const slotsByStartTime = {};\r\n        professionalSlots.forEach(slot => {\r\n            const [hour, minute] = slot.start.split(':').map(Number);\r\n            const key = `${hour}:${minute}`;\r\n            slotsByStartTime[key] = slot;\r\n        });\r\n        \r\n        // Pre-create styles for hover state to reduce object creation during render\r\n        const hoverStyle = {\r\n            position: 'absolute',\r\n            bottom: '2px',\r\n            right: '2px',\r\n            fontSize: '10px',\r\n            color: '#666',\r\n            pointerEvents: 'none',\r\n            backgroundColor: 'rgba(255, 255, 255, 0.7)',\r\n            padding: '1px 3px',\r\n            borderRadius: '2px',\r\n            zIndex: 200\r\n        };\r\n        \r\n        // Iterate through each time slot for this professional\r\n        for (let hour = startHour; hour <= endHour; hour++) {\r\n            for (let minuteIndex = 0; minuteIndex < slotsPerHour; minuteIndex++) {\r\n                const minute = minuteIndex * slotDuration;\r\n                const timeKey = `${hour}:${minute}`;\r\n                const displayTimeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\r\n                \r\n                // Check if this cell is the start of a time slot\r\n                const slot = slotsByStartTime[timeKey];\r\n                \r\n                const isHovered = this.state.hoveredCell && \r\n                                this.state.hoveredCell.professionalId === professional.id && \r\n                                this.state.hoveredCell.hour === hour &&\r\n                                this.state.hoveredCell.minute === minute;\r\n                \r\n                // Format time for display in the hover tooltip\r\n                const timeDisplay = this.formatTime(hour, minute);\r\n                \r\n                // Create a consistent cell style with proper borders\r\n                // Hour borders are thicker for better visual separation\r\n                const cellStyle = {\r\n                    ...styles.dashGanttTimeCell,\r\n                    backgroundColor: isHovered ? '#fafafa' : 'transparent',\r\n                    borderLeft: minute === 0 ? '1px solid #eaeaea' : 'none',  // Only show left border at hour boundaries\r\n                    position: 'relative'\r\n                };\r\n                \r\n                // Create the cell for this time slot\r\n                const cell = (\r\n                    <td \r\n                        key={`cell-${professional.id}-${displayTimeKey}`} \r\n                        style={cellStyle}\r\n                        onClick={() => this.handleCreateSlot(professional.id, hour, minute)}\r\n                        onMouseEnter={() => this.handleCellHover(professional.id, hour, minute)}\r\n                        onMouseLeave={this.handleCellLeave}\r\n                        title={`Time: ${timeDisplay}`}\r\n                    >\r\n                        {slot && this.renderSlotRectangle(slot)}\r\n                        \r\n                        {/* Show time on hover */}\r\n                        {isHovered && (\r\n                            <div style={{\r\n                                position: 'absolute', \r\n                                bottom: '2px', \r\n                                right: '2px', \r\n                                fontSize: '10px', \r\n                                color: '#666', \r\n                                pointerEvents: 'none',\r\n                                backgroundColor: 'rgba(255, 255, 255, 0.8)', \r\n                                padding: '1px 3px', \r\n                                borderRadius: '2px', \r\n                                zIndex: 200,\r\n                                border: '1px solid #eaeaea'\r\n                            }}>\r\n                                {timeDisplay}\r\n                            </div>\r\n                        )}\r\n                    </td>\r\n                );\r\n                \r\n                cells.push(cell);\r\n            }\r\n        }\r\n        \r\n        return cells;\r\n    }\r\n    \r\n    // Get cached slot width or calculate it if not in cache\r\n    getSlotWidth(slot, slotDuration) {\r\n        if (!slot || !slot.start || !slot.end || !slotDuration) {\r\n            return 1; // Default to 1 if any required values are missing\r\n        }\r\n        \r\n        // Create a unique key for this slot and duration\r\n        const cacheKey = `${slot.id}_${slot.start}_${slot.end}_${slotDuration}`;\r\n        \r\n        // If we have a cached value, use it\r\n        if (this.state.slotWidthCache[cacheKey] !== undefined) {\r\n            return this.state.slotWidthCache[cacheKey];\r\n        }\r\n        \r\n        // Otherwise, calculate and cache the value\r\n        const width = this.calculateSlotWidth(slot.start, slot.end, slotDuration);\r\n        \r\n        // Update the cache (without triggering a re-render)\r\n        // We can safely update state directly here since we're not using setState\r\n        // and this won't trigger a re-render - it's just for caching\r\n        this.state.slotWidthCache[cacheKey] = width;\r\n        \r\n        return width;\r\n    }\r\n    \r\n    // Optimize rendering by preventing unnecessary re-renders\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        // We need to allow hover state changes to trigger re-renders for hover effects\r\n        // but we can still optimize by not recalculating slot widths\r\n        \r\n        // For any state or prop changes, we should re-render\r\n        // But we can optimize calculations inside the render cycle\r\n        return true;\r\n    }\r\n    \r\n    // Reset cache when props change\r\n    componentDidUpdate(prevProps) {\r\n        // If timeslots change, clear the width cache to ensure correct calculations\r\n        if (prevProps.timeslots !== this.props.timeslots || \r\n            prevProps.slotDuration !== this.props.slotDuration) {\r\n            this.setState({\r\n                slotWidthCache: {}\r\n            });\r\n        }\r\n    }\r\n    \r\n    // Update raw data when timeslots change\r\n    updateRawData(timeslots) {\r\n        const { rawData, onDataChange, setProps } = this.props;\r\n        \r\n        // Create a fresh array for the updated raw data\r\n        // Instead of just creating a copy and modifying it\r\n        let updatedRawData = [];\r\n        \r\n        // First, filter existing data if needed\r\n        if (rawData && rawData.length > 0) {\r\n            // Keep track of which timeslots are still valid\r\n            const validTimeslots = new Set();\r\n            \r\n            // Generate lookup keys for all currently valid timeslots\r\n            timeslots.forEach(slot => {\r\n                const doctorName = this.state.professionals.find(p => p.id === slot.professionalId)?.name;\r\n                if (doctorName) {\r\n                    const key = `${slot.date} ${slot.start}_${doctorName}`;\r\n                    validTimeslots.add(key);\r\n                }\r\n            });\r\n            \r\n            // Only keep raw data items that correspond to slots we still have\r\n            updatedRawData = rawData.filter(item => {\r\n                // Skip items that don't have the required fields\r\n                if (!item.datetime || !item.laakari) return false;\r\n                \r\n                // Create a key to match against our valid timeslots\r\n                const key = `${item.datetime}_${item.laakari}`;\r\n                return validTimeslots.has(key);\r\n            });\r\n        }\r\n        \r\n        // Now process all current timeslots to update or add them\r\n        timeslots.forEach(timeslot => {\r\n            const originalData = timeslot.rawData;\r\n            const doctorName = this.state.professionals.find(p => p.id === timeslot.professionalId)?.name;\r\n            if (!doctorName) return;\r\n            \r\n            // For existing slots\r\n            if (originalData) {\r\n                // Calculate duration from start and end time\r\n                const [startHours, startMinutes] = timeslot.start.split(':').map(Number);\r\n                const [endHours, endMinutes] = timeslot.end.split(':').map(Number);\r\n                \r\n                // Handle crossing midnight if needed\r\n                let durationMinutes;\r\n                if (endHours < startHours || (endHours === startHours && endMinutes < startMinutes)) {\r\n                    // End time is on the next day\r\n                    durationMinutes = ((endHours + 24) * 60 + endMinutes) - (startHours * 60 + startMinutes);\r\n                } else {\r\n                    durationMinutes = (endHours * 60 + endMinutes) - (startHours * 60 + startMinutes);\r\n                }\r\n                \r\n                // Find the corresponding row in the filtered raw data\r\n                const rowIndex = updatedRawData.findIndex(row => \r\n                    row.datetime === `${timeslot.date} ${timeslot.start}` &&\r\n                    row.laakari === doctorName\r\n                );\r\n                \r\n                if (rowIndex !== -1) {\r\n                    // Update the existing row\r\n                    updatedRawData[rowIndex] = {\r\n                        ...updatedRawData[rowIndex],\r\n                        datetime: `${timeslot.date} ${timeslot.start}`,\r\n                        kesto_min: durationMinutes,\r\n                        tyhja: timeslot.isBooked ? 0 : 1,\r\n                        bookingProbability: timeslot.bookingProbability || 0.5\r\n                    };\r\n                } else {\r\n                    // The row was removed during filtering, add it back\r\n                    updatedRawData.push({\r\n                        datetime: `${timeslot.date} ${timeslot.start}`,\r\n                        laakari: doctorName,\r\n                        kesto_min: durationMinutes,\r\n                        tyhja: timeslot.isBooked ? 0 : 1,\r\n                        bookingProbability: timeslot.bookingProbability || 0.5\r\n                    });\r\n                }\r\n            } \r\n            // For new slots\r\n            else if (!originalData && timeslot.start && timeslot.end) {\r\n                // Calculate duration\r\n                const [startHours, startMinutes] = timeslot.start.split(':').map(Number);\r\n                const [endHours, endMinutes] = timeslot.end.split(':').map(Number);\r\n                \r\n                let durationMinutes;\r\n                if (endHours < startHours || (endHours === startHours && endMinutes < startMinutes)) {\r\n                    durationMinutes = ((endHours + 24) * 60 + endMinutes) - (startHours * 60 + startMinutes);\r\n                } else {\r\n                    durationMinutes = (endHours * 60 + endMinutes) - (startHours * 60 + startMinutes);\r\n                }\r\n                \r\n                // Create and add a new row\r\n                updatedRawData.push({\r\n                    datetime: `${timeslot.date} ${timeslot.start}`,\r\n                    laakari: doctorName,\r\n                    kesto_min: durationMinutes,\r\n                    tyhja: timeslot.isBooked ? 0 : 1,\r\n                    bookingProbability: timeslot.bookingProbability || 0.5,\r\n                    toimipiste: \"Default\",\r\n                    aikaryhman: \"Default\",\r\n                    aikaryhma: \"Default\",\r\n                    RESURSSI: \"Default\",\r\n                    specialty: \"Default\",\r\n                    ETNS_A: 1,\r\n                    ETNS_B: 1\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Call the callback if provided\r\n        if (onDataChange) {\r\n            onDataChange(updatedRawData);\r\n        }\r\n\r\n        // Update Dash props if setProps is available\r\n        if (setProps) {\r\n            setProps({ rawData: updatedRawData });\r\n        }\r\n    }\r\n    \r\n    render() {\r\n        const { id, date, startHour, endHour, slotDuration, backgroundColor } = this.props;\r\n        const { professionals, timeslots } = this.state;\r\n        \r\n        // Calculate number of time slots per hour (e.g., 12 for 5-minute slots)\r\n        const slotsPerHour = 60 / slotDuration;\r\n        \r\n        // Calculate total number of slots in the timeline\r\n        const totalSlots = (endHour - startHour) * slotsPerHour;\r\n        \r\n        // Calculate a reasonable cell width in pixels - each hour should be at least 60px wide\r\n        const hourWidth = 60;\r\n        const cellWidth = hourWidth / slotsPerHour;\r\n        \r\n        const styles = {\r\n            dashGantt: {\r\n                fontFamily: 'Arial, sans-serif',\r\n                margin: '20px 0'\r\n            },\r\n            dashGanttHeader: {\r\n                marginBottom: '10px'\r\n            },\r\n            dashGanttContainer: {\r\n                border: '1px solid #e0e0e0', // Even lighter border for simple_white theme\r\n                borderRadius: '4px', // Less rounded corners for clean look\r\n                overflow: 'hidden',\r\n                overflowX: 'auto',\r\n                boxShadow: 'none' // No shadow for minimalist look\r\n            },\r\n            dashGanttTable: {\r\n                width: '100%',\r\n                borderCollapse: 'collapse',\r\n                tableLayout: 'fixed',\r\n                // Each hour is at least hourWidth pixels, plus professional column\r\n                minWidth: `${150 + (endHour - startHour) * hourWidth}px`\r\n            },\r\n            dashGanttHeaderRow: {\r\n                backgroundColor: backgroundColor || '#ffffff' // White background like simple_white theme\r\n            },\r\n            dashGanttHeaderCell: {\r\n                padding: '12px 8px', \r\n                textAlign: 'center',\r\n                fontWeight: '500', // Medium weight for cleaner look\r\n                borderRight: '1px solid #eaeaea', // Very light border\r\n                borderBottom: '1px solid #eaeaea',\r\n                fontSize: '14px',\r\n                color: '#444' // Darker text for better readability\r\n            },\r\n            dashGanttFirstHeaderCell: {\r\n                width: '150px',\r\n                borderRight: '1px solid #eaeaea',\r\n                borderBottom: '1px solid #eaeaea'\r\n            },\r\n            dashGanttRow: {\r\n                height: '60px'\r\n            },\r\n            dashGanttProfessionalCell: {\r\n                width: '150px',\r\n                padding: '8px',\r\n                borderRight: '1px solid #eaeaea',\r\n                borderBottom: '1px solid #eaeaea',\r\n                backgroundColor: backgroundColor || '#ffffff', // Use same background color as headers\r\n                verticalAlign: 'middle',\r\n                fontWeight: '500',\r\n                fontSize: '14px',\r\n                color: '#444'\r\n            },\r\n            dashGanttTimeCell: {\r\n                position: 'relative',\r\n                padding: '0',\r\n                borderRight: '1px solid #f5f5f5', // Very subtle grid lines\r\n                borderBottom: '1px solid #eaeaea',\r\n                cursor: 'pointer',\r\n                height: '60px',\r\n                // We're setting a minimum width based on a reasonable cell size\r\n                minWidth: '5px', \r\n                width: `${100 / totalSlots}%`,\r\n                boxSizing: 'border-box',\r\n                transition: 'background-color 0.2s ease'\r\n            },\r\n            dashGanttSlot: {\r\n                position: 'absolute',\r\n                top: '0',\r\n                height: '100%',\r\n                backgroundColor: '#4CAF50',\r\n                color: 'white',\r\n                borderRadius: '4px',\r\n                display: 'flex',\r\n                justifyContent: 'center',\r\n                alignItems: 'center',\r\n                cursor: 'pointer',\r\n                boxShadow: '0 1px 3px rgba(0,0,0,0.1)', // Lighter shadow for cleaner look\r\n                zIndex: 10,\r\n                overflow: 'hidden'\r\n            },\r\n            dashGanttProbability: {\r\n                fontSize: '14px',\r\n                fontWeight: '500'\r\n            },\r\n            dashGanttEditor: {\r\n                marginTop: '20px',\r\n                padding: '15px',\r\n                border: '1px solid #eaeaea', // Lighter border for simple_white\r\n                borderRadius: '4px',\r\n                backgroundColor: '#ffffff' // Pure white background\r\n            },\r\n            dashGanttForm: {\r\n                display: 'flex',\r\n                flexDirection: 'column',\r\n                gap: '10px'\r\n            },\r\n            dashGanttFormGroup: {\r\n                display: 'flex',\r\n                alignItems: 'center'\r\n            },\r\n            dashGanttFormGroupLabel: {\r\n                width: '100px',\r\n                marginRight: '10px',\r\n                color: '#444',\r\n                fontSize: '14px'\r\n            },\r\n            dashGanttFormGroupInput: {\r\n                flex: 1,\r\n                padding: '8px',\r\n                border: '1px solid #eaeaea',\r\n                borderRadius: '4px',\r\n                fontSize: '14px'\r\n            },\r\n            dashGanttFormActions: {\r\n                display: 'flex',\r\n                gap: '10px',\r\n                marginTop: '10px'\r\n            },\r\n            dashGanttFormActionsButton: {\r\n                padding: '8px 15px',\r\n                border: 'none',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontWeight: '500',\r\n                fontSize: '14px'\r\n            },\r\n            dashGanttFormActionsSave: {\r\n                backgroundColor: '#2196F3', // Using blue for primary action\r\n                color: 'white'\r\n            },\r\n            dashGanttFormActionsCancel: {\r\n                backgroundColor: '#f5f5f5',\r\n                color: '#333'\r\n            },\r\n            dashGanttFormActionsRemove: {\r\n                backgroundColor: '#f44336',\r\n                color: 'white'\r\n            }\r\n        };\r\n        \r\n        // Generate hour labels\r\n        const hourLabels = [];\r\n        for (let hour = startHour; hour <= endHour; hour++) {\r\n            const displayHour = hour % 24; // Handle 24-hour format\r\n            const isPM = displayHour >= 12;\r\n            const display12Hour = displayHour === 0 ? 12 : (displayHour > 12 ? displayHour - 12 : displayHour);\r\n            const timeLabel = `${display12Hour}${isPM ? 'PM' : 'AM'}`;\r\n            hourLabels.push(timeLabel);\r\n        }\r\n        \r\n        // Generate hour header cells\r\n        const generateHourHeaderCells = () => {\r\n            const cells = [];\r\n            \r\n            for (let hour = startHour; hour <= endHour; hour++) {\r\n                // Use 24-hour format (European style)\r\n                // Ensure we're not exceeding 24 hours (handle edge case for endHour=24)\r\n                const displayHour = hour === 24 ? 24 : hour % 24;\r\n                // Format as 2-digit hour (e.g., \"06\" instead of \"6\")\r\n                const timeLabel = `${displayHour.toString().padStart(2, '0')}:00`;\r\n                \r\n                cells.push(\r\n                    <th \r\n                        key={`header-${hour}`} \r\n                        colSpan={slotsPerHour}\r\n                        style={styles.dashGanttHeaderCell}\r\n                    >\r\n                        {timeLabel}\r\n                    </th>\r\n                );\r\n            }\r\n            \r\n            return cells;\r\n        };\r\n\r\n        return (\r\n            <div id={id} style={styles.dashGantt}>\r\n                <div style={styles.dashGanttHeader}>\r\n                    <h2>Schedule for {date}</h2>\r\n                </div>\r\n                <div style={styles.dashGanttContainer}>\r\n                    <table style={styles.dashGanttTable}>\r\n                        <thead>\r\n                            <tr style={styles.dashGanttHeaderRow}>\r\n                                <th style={styles.dashGanttFirstHeaderCell}></th>\r\n                                {generateHourHeaderCells()}\r\n                            </tr>\r\n                        </thead>\r\n                        <tbody>\r\n                            {professionals.map(professional => (\r\n                                <tr key={`row-${professional.id}`} style={styles.dashGanttRow}>\r\n                                    <td style={styles.dashGanttProfessionalCell}>\r\n                                        {professional.name}\r\n                                    </td>\r\n                                    {this.generateTimeCells(professional, styles)}\r\n                                </tr>\r\n                            ))}\r\n                        </tbody>\r\n                    </table>\r\n                </div>\r\n                \r\n                {/* Render slot editor */}\r\n                {this.state.selectedSlot || this.state.isAddingSlot ? (\r\n                    <div style={styles.dashGanttEditor}>\r\n                        <h3>{this.state.isAddingSlot ? 'Add New Slot' : 'Edit Slot'}</h3>\r\n                        <div style={styles.dashGanttForm}>\r\n                            <div style={styles.dashGanttFormGroup}>\r\n                                <label style={styles.dashGanttFormGroupLabel}>Professional:</label>\r\n                                <select \r\n                                    style={styles.dashGanttFormGroupInput}\r\n                                    value={this.state.isAddingSlot ? this.state.newSlot.professionalId : this.state.selectedSlot.professionalId} \r\n                                    onChange={e => {\r\n                                        const professionalId = parseInt(e.target.value);\r\n                                        if (this.state.isAddingSlot) {\r\n                                            this.setState({ newSlot: { ...this.state.newSlot, professionalId } });\r\n                                        } else {\r\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, professionalId } });\r\n                                        }\r\n                                    }}\r\n                                    disabled={!this.state.isAddingSlot}\r\n                                >\r\n                                    {professionals.map(p => (\r\n                                        <option key={p.id} value={p.id}>{p.name}</option>\r\n                                    ))}\r\n                                </select>\r\n                            </div>\r\n                            <div style={styles.dashGanttFormGroup}>\r\n                                <label style={styles.dashGanttFormGroupLabel}>Start Time:</label>\r\n                                <input \r\n                                    type=\"time\" \r\n                                    style={styles.dashGanttFormGroupInput}\r\n                                    value={this.state.isAddingSlot ? this.state.newSlot.start : this.state.selectedSlot.start} \r\n                                    onChange={e => {\r\n                                        const start = e.target.value;\r\n                                        if (this.state.isAddingSlot) {\r\n                                            this.setState({ newSlot: { ...this.state.newSlot, start } });\r\n                                        } else {\r\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, start } });\r\n                                        }\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                            <div style={styles.dashGanttFormGroup}>\r\n                                <label style={styles.dashGanttFormGroupLabel}>End Time:</label>\r\n                                <input \r\n                                    type=\"time\" \r\n                                    style={styles.dashGanttFormGroupInput}\r\n                                    value={this.state.isAddingSlot ? this.state.newSlot.end : this.state.selectedSlot.end} \r\n                                    onChange={e => {\r\n                                        const end = e.target.value;\r\n                                        if (this.state.isAddingSlot) {\r\n                                            this.setState({ newSlot: { ...this.state.newSlot, end } });\r\n                                        } else {\r\n                                            this.setState({ selectedSlot: { ...this.state.selectedSlot, end } });\r\n                                        }\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                            <div style={styles.dashGanttFormActions}>\r\n                                <button \r\n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsSave}}\r\n                                    onClick={this.handleSaveSlot}\r\n                                >\r\n                                    Save\r\n                                </button>\r\n                                <button \r\n                                    style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsCancel}}\r\n                                    onClick={this.handleCancelEdit}\r\n                                >\r\n                                    Cancel\r\n                                </button>\r\n                                {!this.state.isAddingSlot && (\r\n                                    <button \r\n                                        style={{...styles.dashGanttFormActionsButton, ...styles.dashGanttFormActionsRemove}}\r\n                                        onClick={() => this.handleRemoveSlot(this.state.selectedSlot.id)}\r\n                                    >\r\n                                        Remove\r\n                                    </button>\r\n                                )}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                ) : null}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nDashGantt.defaultProps = {\r\n    rawData: [],\r\n    date: new Date().toISOString().split('T')[0],\r\n    startHour: 6,\r\n    endHour: 24,\r\n    slotDuration: 20,\r\n    backgroundColor: '#f5f5f5',\r\n    onDataChange: null\r\n};\r\n\r\nDashGantt.propTypes = {\r\n    id: PropTypes.string,\r\n    rawData: PropTypes.arrayOf(\r\n        PropTypes.shape({\r\n            datetime: PropTypes.string.isRequired,\r\n            laakari: PropTypes.string.isRequired,\r\n            kesto_min: PropTypes.number.isRequired,\r\n            tyhja: PropTypes.number.isRequired\r\n        })\r\n    ),\r\n    date: PropTypes.string,\r\n    startHour: PropTypes.number,\r\n    endHour: PropTypes.number,\r\n    slotDuration: PropTypes.number,\r\n    backgroundColor: PropTypes.string,\r\n    onDataChange: PropTypes.func,\r\n    setProps: PropTypes.func\r\n};\r\n"],"names":["DashGantt","_Component","props","_this","_classCallCheck","_callSuper","rawData","date","_DashGantt$transformD","transformData","Date","toISOString","split","professionals","timeslots","state","selectedSlot","isAddingSlot","newSlot","professionalId","start","end","hoveredCell","slotWidthCache","handleSlotClick","bind","handleAddSlot","handleCreateSlot","handleRemoveSlot","handleSaveSlot","handleCancelEdit","handleCellHover","handleCellLeave","renderSlotRectangle","generateTimeCells","formatTime","timeToDecimal","calculateSlotWidth","getSlotWidth","updateRawData","_inherits","key","value","_this$props","this","_DashGantt$transformD2","setState","slot","hour","minute","currentHover","_this$state","startHour","Math","floor","startMinutes","startTime","concat","toString","padStart","totalEndMinutes","endHour","endMinutes","endTime","slotToAdd","id","length","max","apply","_toConsumableArray","map","bookingProbability","isBooked","appointmentType","resource","updatedTimeslots","slotDuration","endTimeInMinutes","slotId","filter","_this$state2","_objectSpread","timeStr","_timeStr$split$map2","_slicedToArray","Number","startDecimal","durationInMinutes","numCells","round","decimal","hours","minutes","probability","undefined","p","min","colorPalette","_this2","numCellsToSpan","slotStyle","position","top","left","height","width","boxSizing","backgroundColor","getProbabilityColor","color","borderRadius","display","justifyContent","alignItems","cursor","boxShadow","zIndex","transition","opacity","React","style","onClick","e","stopPropagation","onContextMenu","preventDefault","title","error","console","professional","styles","_this3","_this$props2","slotsPerHour","cells","professionalSlots","slotsByStartTime","forEach","_slot$start$split$map2","_loop","_loop2","minuteIndex","timeKey","displayTimeKey","isHovered","timeDisplay","cellStyle","dashGanttTimeCell","borderLeft","cell","onMouseEnter","onMouseLeave","bottom","right","fontSize","pointerEvents","padding","border","push","cacheKey","nextProps","nextState","prevProps","_this4","_this$props3","onDataChange","setProps","updatedRawData","validTimeslots","Set","_this4$state$professi","doctorName","find","name","add","item","datetime","laakari","has","timeslot","_this4$state$professi2","originalData","durationMinutes","_timeslot$start$split2","startHours","_timeslot$end$split$m2","endHours","rowIndex","findIndex","row","kesto_min","tyhja","_timeslot$start$split4","_timeslot$end$split$m4","toimipiste","aikaryhman","aikaryhma","RESURSSI","specialty","ETNS_A","ETNS_B","_this5","_this$props4","_this$state3","totalSlots","dashGantt","fontFamily","margin","dashGanttHeader","marginBottom","dashGanttContainer","overflow","overflowX","dashGanttTable","borderCollapse","tableLayout","minWidth","dashGanttHeaderRow","dashGanttHeaderCell","textAlign","fontWeight","borderRight","borderBottom","dashGanttFirstHeaderCell","dashGanttRow","dashGanttProfessionalCell","verticalAlign","dashGanttSlot","dashGanttProbability","dashGanttEditor","marginTop","dashGanttForm","flexDirection","gap","dashGanttFormGroup","dashGanttFormGroupLabel","marginRight","dashGanttFormGroupInput","flex","dashGanttFormActions","dashGanttFormActionsButton","dashGanttFormActionsSave","dashGanttFormActionsCancel","dashGanttFormActionsRemove","hourLabels","displayHour","isPM","timeLabel","colSpan","generateHourHeaderCells","onChange","parseInt","target","disabled","type","filteredData","Array","from","doctor","idx","doctorToId","Object","fromEntries","_row$datetime$split2","time","_time$split$map2","startDate","setHours","endDate","getTime","getHours","getMinutes","prevState","_DashGantt$transformD3","Component","defaultProps","propTypes","PropTypes","isRequired"],"sourceRoot":""}